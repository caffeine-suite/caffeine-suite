import &StandardImport, &BabelBridge

->
  ## @rule
    value: "simpleValue valueExtension*"
    simpleValue:
      :require
      :tagMacro
      :globalIdentifier
      :this
      :thisProperty
      :literal
      :super
      :unqualifiedIdentifier
      :parentheticalExpression

    unqualifiedIdentifier:
      pattern: "!reservedWord identifierReference assignmentExtension?"

  @rule
    value:
      "valueBase blockValueExtension*"

    valueBase:
      "assignableValue assignmentExtension?"
      :nonAssignableValue

    simpleAssignableValue:
      :thisProperty
      :identifierReference

    assignableValue:
      "simpleAssignableValue assignableValueExtension* !functionInvocationExtension"
      "'(' _? assignableValue _? ')' assignableValueExtension* !functionInvocationExtension"
      "parentheticalExpression assignableValueExtension+"
      "nonAssignableValue assignableValueExtension+"

    assignableValueExtension: :dotAccessor :bracketAccessor
    nonAssignableValue:
      :functionInvocation
      :parentheticalExpression
      :simpleNonAssignableValue

    simpleValue:
      :simpleNonAssignableValue
      :simpleAssignableValue

    simpleNonAssignableValue:
      :require
      :tagMacro
      :globalIdentifier
      :this
      :literal
      :super

    functionInvocation:
      "simpleValue extendedFunctionInvocationExtension+"
      "parentheticalExpression extendedFunctionInvocationExtension+"

    extendedFunctionInvocationExtension:
      "assignableValueExtension* functionInvocationExtension"

  @rule
    parentheticalExpression: "'(' _? expression _? ')'"
    valueExtension: :dotAccessor :bracketAccessor :functionInvocationExtension :blockValueExtension

  @rule
    identifierReference:
      pattern:    "" !super !globalIdentifier !reservedWord identifier
      stnFactory: :ReferenceStn

  @rule
    this:         "/@/ !identifier"
    thisProperty: "/@/ identifier assignmentExtension?"
    {} stnFactory: :ThisStn

  @rule
    globalIdentifier:
      pattern: /(global|require|module|eval|this)\b/
      stnFactory: :GlobalIdentifierStn
      stnProps: ~> identifier: @text

  @rule
    super:
      pattern:    "/super\\b/ superFunctionInvocation"
      stnFactory: :SuperStn

  @rule
    super:
      pattern:    /super\b/
      stnFactory: :SuperStn
      stnProps:   passArguments: true

  @rule
    blockValueExtension: "_? blockValueExtensionBlock"
    blockValueExtensionBlock: Extensions.IndentBlocks.getPropsToSubparseBlock rule: "blockValueExtensionSubparse"
    blockValueExtensionSubparse:
      "lineStartComment* &dotOrQuestionDot valueExtension+ binaryOperatorSequenceExtension? newLineStatementExtension* end"
      "lineStartComment* lineStartBinaryOperatorAndExpression newLineStatementExtension* end"

    dotOrQuestionDot: /\??\./

  @rule
    requiredValue:
      "_? _end? implicitArrayOrExpression"
      "_? rValueBlock"

    rValueBlock: Extensions.IndentBlocks.getPropsToSubparseBlock rule: "rValueBlockSubParse"
    rValueBlockSubParse:
      pattern: "root"
      getStn: ~>
        {statements} = @root
        if statements.length == 1
          statements[0].getStn()
        else
          &StnRegistry.ArrayStn @root.getMatchStns()
