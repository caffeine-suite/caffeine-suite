"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["SemanticTree", "Error", "log", "UniqueIdentifierHandle"], [global, require('./StandardImport'), require('caffeine-eight'), require('../SemanticTree')], (SemanticTree, Error, log, UniqueIdentifierHandle) => {let depthFirstTraversal, findAllStnsByType, depthFirstTransformR, depthFirstTransform; depthFirstTraversal = function(stn, applicator) {let from, into, to, i; from = stn.children; into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let child; child = from[i]; depthFirstTraversal(child, applicator); i++;};}; into; return applicator(stn);}; findAllStnsByType = function(rootStn, type) {let dotRefs; dotRefs = []; depthFirstTraversal(rootStn, (stn) => (stn.type === type) ? dotRefs.push(stn) : undefined); return dotRefs;}; depthFirstTransformR = function(stn, transform, recursionTest) {let newChildren, children, e, from, into, to, i1, temp; return (() => {try {newChildren = null; from = children = stn.children; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let child, i, shouldRecurse, newChild; child = from[i1]; i = i1; shouldRecurse = recursionTest ? recursionTest(child) : true; if (shouldRecurse && child !== (newChild = depthFirstTransformR(child, transform))) {newChildren != null ? newChildren : newChildren = children.slice(); newChild.props.label = child.label; newChildren[i] = newChild;}; i1++;};}; into; return transform(stn.withChildren(newChildren || children));} catch (error) {e = error; ((temp = e.stn) != null ? temp : e.stn = stn); return (() => {throw e;})();};})();}; depthFirstTransform = function(stn, transform, recursionTest) {let e, ce; return (() => {try {return depthFirstTransformR(stn, transform, recursionTest);} catch (error) {e = error; return e.stn ? (ce = e.stn.parseTreeNode.parser.generateCompileError({failureIndex: e.stn.sourceOffset, errorType: "Transform", message: e.message, info: e.info}), ce.stack = e.stack, (() => {throw ce;})()) : (() => {throw e;})();};})();}; return function(rootStn) {let AssignmentStn, IdentifierStn, ReferenceStn, AccessorStn, dotRefs, parentStatementsAndChild, parentStatementsNodes; ({AssignmentStn, IdentifierStn, ReferenceStn, AccessorStn} = SemanticTree); dotRefs = findAllStnsByType(rootStn, "DotReference"); return (dotRefs.length > 0) ? (parentStatementsAndChild = Caf.array(dotRefs, (dotRef) => dotRef.findParent("Statements", true)), parentStatementsNodes = Caf.array(parentStatementsAndChild, ({parent}) => parent), depthFirstTransform(rootStn, (stn) => {let statements, child, referencingChildIndex, dotRefIdentifierHandle, temp; return (Caf.exists(temp = parentStatementsAndChild[parentStatementsNodes.indexOf(statements = stn)]) ? child = temp.child : undefined) ? (() => {switch (referencingChildIndex = statements.children.indexOf(child)) {case -1: return (() => {throw new Error("DotReference internal error.");})(); case 0: return (() => {throw new Error("DotReference is not supported yet in first statements.");})(); default: log('rewriting children for "tail statements" DotReferenceTransform...'); dotRefIdentifierHandle = null; return statements.withChildren(Caf.array(statements.children, (child, i) => (() => {switch (referencingChildIndex) {case i + 1: log("adding AssignmentStn"); return AssignmentStn(IdentifierStn({identifierHandle: dotRefIdentifierHandle = new UniqueIdentifierHandle("dotRef")}), child); case i: log("adding ReferenceStn"); return depthFirstTransform(child, (lookingForDotRefStn) => {let dotRef, reference, accessorIdentifier, base; return ((dotRef = lookingForDotRefStn).type === "DotReference") ? (reference = ReferenceStn({identifierHandle: dotRefIdentifierHandle}), (accessorIdentifier = Caf.exists(base = dotRef.children) && base[0]) ? AccessorStn(reference, accessorIdentifier) : reference) : lookingForDotRefStn;}, (dontRecurseOnStatementsStn) => dontRecurseOnStatementsStn !== "Statements");};})()));};})() : stn;})) : rootStn;};});});
//# sourceMappingURL=DotReferenceTransform.js.map
