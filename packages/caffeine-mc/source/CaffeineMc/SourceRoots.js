// Generated by CoffeeScript 1.12.7
(function() {
  var BaseClass, SourceRoots, array, defineModule, each, find, fs, log, merge, path, present, ref, w,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, array = ref.array, log = ref.log, merge = ref.merge, present = ref.present, find = ref.find, each = ref.each, w = ref.w;

  BaseClass = require('art-class-system').BaseClass;

  fs = require('fs-extra');

  path = require('path');

  defineModule(module, SourceRoots = (function(superClass) {
    var _Metacompiler, defaultSourceRootIndicatorFiles, evalCapturingModuleExports, newMetacompiler;

    extend(SourceRoots, superClass);

    function SourceRoots() {
      return SourceRoots.__super__.constructor.apply(this, arguments);
    }

    SourceRoots.classGetter("sourceRootIndicatorFiles knownSourceRoots caffeineInits", {
      caffeineInitFileName: function() {
        return "caffeine-mc.config.caf";
      }
    });

    _Metacompiler = null;

    newMetacompiler = function() {
      return new (_Metacompiler != null ? _Metacompiler : _Metacompiler = require('./Metacompiler'));
    };

    evalCapturingModuleExports = function(source) {
      var e, exports;
      global.__caffeineMcModule = {};
      try {
        eval("(function(module){ " + source + " })(__caffeineMcModule);");
      } catch (error) {
        e = error;
        log.error({
          "ERROR evalCapturingModuleExports": {
            source: source,
            error: e
          }
        });
        throw e;
      }
      exports = (global.__caffeineMcModule || {}).exports;
      global.__caffeineMcModule = null;
      return exports;
    };

    SourceRoots.getCaffeineInit = function(sourceRoot) {
      var res, sourceFile;
      if (sourceRoot == null) {
        sourceRoot = process.cwd();
      }
      if ((res = SourceRoots.caffeineInits[sourceRoot]) != null) {
        return Promise.resolve(res);
      } else {
        return fs.exists(sourceFile = path.join(sourceRoot, SourceRoots.caffeineInitFileName)).then(function(exists) {
          var contentsPromise;
          contentsPromise = exists ? fs.readFile(sourceFile).then(function(contents) {
            return contents = contents.toString();
          }) : Promise.resolve(false);
          return contentsPromise.then(function(contents) {
            var metacompiler, result;
            metacompiler = newMetacompiler();
            return SourceRoots.caffeineInits[sourceRoot] = {
              compiler: metacompiler,
              config: (result = contents && metacompiler.compile(contents, {
                sourceFile: sourceFile,
                sourceRoot: sourceRoot
              })) ? evalCapturingModuleExports(result.compiled.js) : {}
            };
          });
        });
      }
    };

    SourceRoots.getCaffeineInitSync = function(sourceRoot) {
      var contents, metacompiler, res, result, sourceFile;
      if (!sourceRoot) {
        throw new Error("no sourceRoot");
      }
      if ((res = SourceRoots.caffeineInits[sourceRoot]) != null) {
        return res;
      } else {
        if (fs.existsSync(sourceFile = path.join(sourceRoot, SourceRoots.caffeineInitFileName))) {
          contents = fs.readFileSync(sourceFile).toString();
          metacompiler = newMetacompiler();
          result = metacompiler.compile(contents, {
            sourceFile: sourceFile,
            sourceRoot: sourceRoot
          });
          return SourceRoots.caffeineInits[sourceRoot] = {
            compiler: metacompiler.compiler,
            config: evalCapturingModuleExports(result.compiled.js)
          };
        } else {
          return false;
        }
      }
    };

    SourceRoots.findSourceRoot = function(directory, rootFiles) {
      if (rootFiles == null) {
        rootFiles = SourceRoots._sourceRootIndicatorFiles;
      }
      directory = path.resolve(directory);
      return fs.stat(directory).then(function(stat) {
        var ret;
        if (!stat.isDirectory()) {
          directory = path.dirname(directory);
        }
        if ((ret = SourceRoots.knownSourceRoots[directory]) != null) {
          return ret;
        } else {
          return SourceRoots._findRootR(directory, rootFiles).then(function(sourceRoot) {
            return SourceRoots.knownSourceRoots[directory] = sourceRoot || false;
          });
        }
      });
    };

    SourceRoots.findSourceRootSync = function(directory, rootFiles) {
      var ret, sourceRoot, stat;
      if (rootFiles == null) {
        rootFiles = SourceRoots._sourceRootIndicatorFiles;
      }
      directory = path.resolve(directory);
      stat = fs.statSync(directory);
      if (!stat.isDirectory()) {
        directory = path.dirname(directory);
      }
      if ((ret = SourceRoots.knownSourceRoots[directory]) != null) {
        return ret;
      } else {
        sourceRoot = SourceRoots._findRootSyncR(directory, rootFiles);
        return SourceRoots.knownSourceRoots[directory] = sourceRoot || false;
      }
    };

    SourceRoots._caffeineInits = {};

    SourceRoots._knownSourceRoots = {};

    SourceRoots._sourceRootIndicatorFiles = defaultSourceRootIndicatorFiles = ["package.json", SourceRoots.caffeineInitFileName];

    SourceRoots._resetSourceRoots = function() {
      SourceRoots._caffeineInits = {};
      SourceRoots._knownSourceRoots = {};
      return SourceRoots._sourceRootIndicatorFiles = defaultSourceRootIndicatorFiles;
    };

    SourceRoots._findRootR = function(directory, rootFiles) {
      return Promise.all(array(rootFiles, function(file) {
        return fs.exists(path.join(directory, file));
      })).then((function(_this) {
        return function(rootFileExistResults) {
          if (find(rootFileExistResults)) {
            return directory;
          } else if (directory !== "/" && present(directory)) {
            return _this._findRootR(path.dirname(directory), rootFiles);
          } else {
            return null;
          }
        };
      })(this));
    };

    SourceRoots._findRootSyncR = function(directory, rootFiles) {
      var rootFileExistResults;
      rootFileExistResults = array(rootFiles, function(file) {
        return fs.existsSync(path.join(directory, file));
      });
      if (find(rootFileExistResults)) {
        return directory;
      } else if (directory !== "/" && present(directory)) {
        return this._findRootSyncR(path.dirname(directory), rootFiles);
      } else {
        return null;
      }
    };

    return SourceRoots;

  })(BaseClass));

}).call(this);
