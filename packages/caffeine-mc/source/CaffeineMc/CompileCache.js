// Generated by CoffeeScript 1.12.7
(function() {
  var BaseClass, CompileCache, Promise, array, consistentJsonStringify, crypto, currentSecond, defineModule, findModuleSync, findSourceRootSync, formattedInspect, fs, glob, isString, log, merge, os, path, randomBase62Character, ref, upperCamelCase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), array = ref.array, merge = ref.merge, formattedInspect = ref.formattedInspect, log = ref.log, defineModule = ref.defineModule, isString = ref.isString, upperCamelCase = ref.upperCamelCase, randomBase62Character = ref.randomBase62Character, consistentJsonStringify = ref.consistentJsonStringify, Promise = ref.Promise, currentSecond = ref.currentSecond;

  BaseClass = require('art-class-system').BaseClass;

  findSourceRootSync = require('./SourceRoots').findSourceRootSync;

  findModuleSync = require('./ModuleResolver').findModuleSync;

  require('colors');

  fs = require('fs-extra');

  glob = require('glob-promise');

  crypto = require('crypto');

  os = require('os');

  path = require('path');


  /*
  cachedFileKey: (object)
    compiler:   (required, object) compiler
    source:     (required, string) source-code
    sourceFile: (required, string) source file path & name
    compilerOptions: (object) all options which affect the generated output
  
  cachedFileKeyWithCompilerResults: (object)
    all the cachedFileKey fields
    compiled: (required, object) the compiler's results
   */

  defineModule(module, CompileCache = (function(superClass) {
    extend(CompileCache, superClass);

    function CompileCache() {
      return CompileCache.__super__.constructor.apply(this, arguments);
    }

    CompileCache.compileCacheFileNameRoot = "CaffineMcCompileCache";

    CompileCache.classGetter({
      compileCachePathRoot: function() {
        return os.tmpdir();
      },
      compileCacheFilePathRoot: function() {
        return this._compileCacheFilePathRoot || (this._compileCacheFilePathRoot = path.join(this.compileCachePathRoot, this.compileCacheFileNameRoot));
      }
    });

    CompileCache.compilerSupportsCaching = function(compiler) {
      return isString(compiler.version) && this.getCompilerName(compiler);
    };

    CompileCache.getCompilerName = function(compiler) {
      return (typeof compiler.getName === "function" ? compiler.getName() : void 0) || compiler.name;
    };

    CompileCache.getCompilerSignature = function(compiler) {
      return (this.getCompilerName(compiler)) + "-" + compiler.version;
    };

    CompileCache.makeSha256FilenameFriendly = function(sha256String) {
      return sha256String.replace(/[\/+=]/g, "-");
    };

    CompileCache.hashSource = function(source) {
      return this.makeSha256FilenameFriendly(crypto.createHmac('sha256', "no need for a real secret").update(source).digest('base64').split("=")[0]);
    };


    /*
    IN: cachedFileKey (see above)
     */

    CompileCache.getFileName = function(cachedFileKey) {
      var compiler, compilerOptions, relativeSourceFile, source, sourceFile, sourceRoot;
      compiler = cachedFileKey.compiler, source = cachedFileKey.source, sourceFile = cachedFileKey.sourceFile, compilerOptions = cachedFileKey.compilerOptions;
      if (!(compiler && sourceFile && (source != null))) {
        throw new Error("expecting compiler, source and sourceFile: " + formattedInspect({
          compiler: compiler,
          source: source,
          sourceFile: sourceFile
        }));
      }
      if (!this.compilerSupportsCaching(compiler)) {
        return null;
      }
      sourceRoot = findSourceRootSync(sourceFile);
      relativeSourceFile = path.relative(sourceRoot, sourceFile);
      source = "# sourceFile: " + relativeSourceFile + "\n# compilerOptions: " + (consistentJsonStringify(compilerOptions != null ? compilerOptions : null)) + "\n" + source;
      return [this.compileCacheFilePathRoot, path.basename(sourceRoot).replace(/\./g, "-"), path.basename(sourceFile).replace(/\./g, "-"), this.getCompilerSignature(compiler), this.hashSource(source)].join("_") + ".json";
    };


    /*
    IN: cachedFileKey (see above), but also with {source, compiled and props}
     */

    CompileCache.cache = function(cachedFileKey) {
      var compiled, fileName, props, source;
      if (fileName = this.getFileName(cachedFileKey)) {
        source = cachedFileKey.source, compiled = cachedFileKey.compiled, props = cachedFileKey.props;
        if (cachedFileKey.verbose) {
          log({
            caching: cachedFileKey.sourceFile
          });
        }
        fs.writeFileSync(fileName, JSON.stringify(merge({
          source: source,
          compiled: compiled,
          props: props
        })));
      }
      return cachedFileKey;
    };


    /*
    IN: cachedFileKey (see above)
     */

    CompileCache.fetch = function(cachedFileKey) {
      var cacheContents, fileName, start;
      start = currentSecond();
      if ((fileName = this.getFileName(cachedFileKey)) && fs.existsSync(fileName)) {
        if ((cacheContents = (function() {
          try {
            return JSON.parse(fs.readFileSync(fileName));
          } catch (error) {}
        })()) && cacheContents.source === cachedFileKey.source && this.verifyDependencies(cachedFileKey, cacheContents.props)) {
          cacheContents.fromCache = true;
          if (cachedFileKey.verbose) {
            log({
              cached: (((currentSecond() - start) * 1000 | 0) + "ms ") + cachedFileKey.sourceFile
            });
          }
          return cacheContents;
        }
      }
    };

    CompileCache.verifyDependencies = function(cachedFileKey, props) {
      var cachedRequireString, moduleDependencies, requireString, sourceString;
      if (moduleDependencies = props != null ? props.moduleDependencies : void 0) {
        for (sourceString in moduleDependencies) {
          cachedRequireString = moduleDependencies[sourceString];
          requireString = findModuleSync(sourceString, {
            sourceFile: cachedFileKey.sourceFile
          }).requireString;
          if (requireString !== cachedRequireString) {
            log({
              CompileCache: {
                message: "moduleDependencies changed",
                sourceString: sourceString,
                sourceFile: cachedFileKey.sourceFile,
                require: {
                  old: cachedRequireString,
                  "new": requireString
                }
              }
            });
            return false;
          }
        }
        return true;
      } else {
        return true;
      }
    };

    CompileCache.reset = function(verbose) {
      return glob(this.compileCacheFilePathRoot + "*").then(function(list) {
        return Promise.all(array(list, function(item) {
          return Promise.resolve(item).then(function(item) {
            return fs.unlink(item);
          }).tap(function() {
            if (verbose) {
              return log("cache-reset: ".gray + item.green + " (deleted)".gray);
            }
          });
        }));
      });
    };

    return CompileCache;

  })(BaseClass));

}).call(this);
