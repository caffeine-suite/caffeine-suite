// Generated by CoffeeScript 1.12.7
(function() {
  var CafRepl, CaffeineMc, Register, compactFlatten, currentSecond, defineModule, displayError, formattedInspect, fs, getCaffeineInit, highlight, historyFile, historyMaxInputSize, isArray, isArrayUniversal, isPlainObjectUniversal, log, maxOutputCharacters, maxOutputLines, merge, objectKeyCount, path, ref, ref1, repl, runInContext;

  ref = require('art-standard-lib'), currentSecond = ref.currentSecond, merge = ref.merge, objectKeyCount = ref.objectKeyCount, isArray = ref.isArray, isArrayUniversal = ref.isArrayUniversal, isPlainObjectUniversal = ref.isPlainObjectUniversal, formattedInspect = ref.formattedInspect, defineModule = ref.defineModule, log = ref.log, compactFlatten = ref.compactFlatten;

  getCaffeineInit = require('./SourceRoots').getCaffeineInit;

  ref1 = CaffeineMc = require('./namespace'), runInContext = ref1.runInContext, displayError = ref1.displayError;

  Register = require('./Register');

  repl = require('repl');

  path = require('path');

  fs = require('fs');

  if (process.env.HOME) {
    historyFile = path.join(process.env.HOME, '.caffeine-mc-history');
  }

  historyMaxInputSize = 10240;

  maxOutputLines = 30;

  maxOutputCharacters = maxOutputLines * 200;

  highlight = require('./Highlight').highlight;

  defineModule(module, CafRepl = (function() {
    var lastCompiler, logReplInfo;

    function CafRepl() {}

    logReplInfo = function(categoryName, info) {
      var out;
      out = categoryName.gray;
      if (info != null) {
        out += info.green;
      }
      return log(out);
    };

    CafRepl.start = function(parser) {
      return getCaffeineInit().then((function(_this) {
        return function(init) {
          var config, evaluateMode, lastOutput, showSource, toggleVerbose, verbose;
          showSource = false;
          evaluateMode = true;
          verbose = false;
          lastOutput = null;
          toggleVerbose = function() {
            return Register.verbose = verbose = !verbose;
          };
          _this.compiler = init.compiler, config = init.config;
          logReplInfo("Welcome to the CaffeineMC console.");
          logReplInfo("For help: ", ".help");
          _this._showCurrentCompiler();
          _this.cafRepl = repl.start({
            prompt: _this.getPrompt(),
            completer: function(command) {
              var __, commandToEval, error, k, key, keys, last, out, regex, result, trimmedCommand;
              trimmedCommand = command.trim();
              commandToEval = (result = trimmedCommand.match(regex = /\.([$\w\u007f-\uffff]*)$/)) ? ((__ = result[0], last = result[1], result), trimmedCommand.split(regex)[0]) : trimmedCommand.match(/^[$\w\u007f-\uffff]*$/) ? (last = trimmedCommand, "global") : trimmedCommand;
              out = (function() {
                try {
                  result = this._replEval(commandToEval);
                  keys = (function() {
                    var ref2, results;
                    results = [];
                    for (k in result) {
                      if (!last || ((ref2 = k.match(last)) != null ? ref2.index : void 0) === 0) {
                        results.push(k);
                      }
                    }
                    return results;
                  })();
                  this.cafRepl.outputStream.write("\n" + (formattedInspect({
                    "tab-completion": merge({
                      object: commandToEval,
                      prefix: last != null ? last : "(none)",
                      found: keys.length <= 3 ? keys.join(', ') : (keys.slice(0, 3).join(', ')) + "..."
                    })
                  }, {
                    color: true
                  })) + (keys.length > 3 ? ("  press tab again to show all " + keys.length + "\n").gray : ""));
                  if (last || /\.$/.test(command)) {
                    return [keys, last];
                  } else {
                    return [
                      (function() {
                        var i, len, results;
                        results = [];
                        for (i = 0, len = keys.length; i < len; i++) {
                          key = keys[i];
                          results.push("." + key);
                        }
                        return results;
                      })(), ""
                    ];
                  }
                } catch (error1) {
                  error = error1;
                  this.cafRepl.outputStream.write("\ntab-completion could not evaluate: " + commandToEval.red + "\n");
                  return [[], trimmedCommand];
                }
              }).call(_this);
              if (out[0].length === 0) {
                _this.cafRepl.displayPrompt(true);
              }
              return out;
            },
            "eval": function(command, context, filename, callback) {
              var e, midTime, result, startTime;
              try {
                startTime = currentSecond();
                if (command.trim() === '') {
                  return callback();
                }
                if (showSource || !evaluateMode) {
                  _this.cafRepl.outputStream.write("Source:\n".grey);
                  _this.cafRepl.outputStream.write(highlight(_this.compileCommand(command, filename)));
                  _this.cafRepl.outputStream.write("\n\n");
                }
                result = evaluateMode ? (showSource ? _this.cafRepl.outputStream.write("Evaluate...\n".grey) : void 0, _this.replEval(command, context, filename)) : ("evaluation off (.evaluate to turn back on)".grey, void 0);
                (_this.replEval("global", context, filename)).$last = result;
                midTime = currentSecond();
                log.resolvePromiseWrapper(result, function(toLog, label, wasResolved, wasRejected) {
                  var finalOut, finalTime, lines, obj, out;
                  finalTime = currentSecond();
                  lastOutput = out = formattedInspect(label ? (
                    obj = {},
                    obj["" + label] = toLog,
                    obj
                  ) : toLog, {
                    color: true
                  });
                  if (showSource && evaluateMode) {
                    _this.cafRepl.outputStream.write("\nOut:\n".grey);
                  }
                  finalOut = ((lines = out.split("\n")).slice(0, maxOutputLines)).join("\n");
                  if (finalOut.length > maxOutputCharacters) {
                    finalOut = finalOut.slice(0, maxOutputCharacters);
                  }
                  if (wasResolved || wasRejected) {
                    log("");
                  }
                  log(finalOut);
                  if (finalOut !== out) {
                    logReplInfo("output truncated");
                    if (isArray(toLog)) {
                      logReplInfo("  array: length: " + toLog.length);
                    } else if (isPlainObjectUniversal(toLog)) {
                      logReplInfo("  object: keys: " + (objectKeyCount(toLog)));
                    }
                    if (lines.length > maxOutputLines) {
                      logReplInfo("  showing: " + maxOutputLines + "/" + lines.length + " lines");
                    } else {
                      logReplInfo("  showing: " + finalOut.length + "/" + lastOutput.length + " characters");
                    }
                    logReplInfo("  show all:                      ", ".last");
                    logReplInfo("  result available at:           ", "$last");
                  }
                  if (wasResolved || wasRejected) {
                    logReplInfo("  promise wall-time:             ", ((finalTime - midTime) * 1000 | 0) + "ms");
                    logReplInfo("  total wall-time:               ", ((finalTime - startTime) * 1000 | 0) + "ms");
                    if (!wasRejected) {
                      logReplInfo("  resolved value available at:   ", "$lastResolved");
                      (_this.replEval("global", context, filename)).$lastResolved = toLog;
                    } else {
                      logReplInfo("  rejected value available at:   ", "$lastRejected");
                      (_this.replEval("global", context, filename)).$lastRejected = toLog;
                    }
                    (_this.replEval("global", context, filename)).$lastPromise = result;
                    logReplInfo("  promise available at:          ", "$lastPromise");
                    return _this.cafRepl.displayPrompt();
                  }
                });
                if (midTime - startTime > .1) {
                  logReplInfo("wall-time: ", ((midTime - startTime) * 1000 | 0) + "ms");
                }
                return callback();
              } catch (error1) {
                e = error1;
                return callback(e);
              }
            }
          });
          _this.setupHistory();
          _this.addCommand({
            name: 'compiler',
            help: 'CaffeineMC: Show the current compiler',
            action: function() {
              _this.cafRepl.outputStream.write(formattedInspect(_this.compiler.current));
              _this.cafRepl.outputStream.write("\n");
              return _this.cafRepl.displayPrompt();
            }
          });
          _this.addCommand({
            name: "last",
            help: "CaffeineMC: Show the last output value in its entirety. $last contains the value of the last output.",
            action: function() {
              _this.cafRepl.outputStream.write("" + lastOutput);
              _this.cafRepl.outputStream.write("\n");
              return _this.cafRepl.displayPrompt();
            }
          });
          _this.addCommand({
            name: "evaluate",
            help: "toggle evaluate command",
            action: function() {
              evaluateMode = !evaluateMode;
              _this.cafRepl.outputStream.write("Evaluate Mode is " + (evaluateMode ? 'On' : 'Off') + "\n");
              return _this.cafRepl.displayPrompt();
            }
          });
          _this.addCommand({
            name: "verbose",
            help: "toggle verbose logging",
            action: function() {
              toggleVerbose();
              _this.cafRepl.outputStream.write("Verbose logging is " + (verbose ? 'On' : 'Off') + "\n");
              return _this.cafRepl.displayPrompt();
            }
          });
          _this.addCommand({
            name: "source",
            help: "toggle show-source",
            action: function() {
              showSource = !showSource;
              _this.cafRepl.outputStream.write("Show-Source Mode is " + (showSource ? 'On' : 'Off') + "\n");
              return _this.cafRepl.displayPrompt();
            }
          });
          return runInContext("Neptune.CaffeineMc.register()", _this.cafRepl.context);
        };
      })(this))["catch"](function(error) {
        return log.error({
          replError: error
        });
      });
    };

    CafRepl.getPrompt = function() {
      return ("caf-mc:" + this.compiler.compilerName + "> ").gray;
    };

    CafRepl.compileCommand = function(command, filename) {
      var e, js;
      command = command.trim();
      js = this.compiler.compile(command, {
        bare: true,
        sourceFile: filename,
        cache: filename !== "repl"
      }).compiled.js;
      try {
        return require("prettier").format(js, {
          parser: 'babel'
        });
      } catch (error1) {
        e = error1;
        return displayError(e);
      }
    };

    CafRepl._showCurrentCompiler = function() {
      return logReplInfo("Your current compiler is: ", this.compiler.compilerName);
    };

    CafRepl._replEval = function(command, context, filename) {
      var js;
      if (context == null) {
        context = this.cafRepl.context;
      }
      if (filename == null) {
        filename = 'repl';
      }
      js = this.compileCommand(command, filename);
      if (command.match(/^\|/)) {
        return this.compiler.lastMetacompilerResult;
      } else {
        return runInContext(js, context);
      }
    };

    lastCompiler = null;

    CafRepl.replEval = function(command, context, filename) {
      var e, error, js, result;
      if (context == null) {
        context = this.cafRepl.context;
      }
      if (filename == null) {
        filename = 'repl';
      }
      result = error = null;
      try {
        js = this.compileCommand(command, filename);
        try {
          result = command.match(/^\|/) ? this.compiler.lastMetacompilerResult : runInContext(js, context);
          if (lastCompiler !== this.compiler) {
            this._showCurrentCompiler();
            lastCompiler = this.compiler;
          }
          this.cafRepl.setPrompt(this.getPrompt());
        } catch (error1) {
          e = error1;
          error = e;
        }
      } catch (error1) {
        e = error1;
        displayError(e);
        result = null;
      }
      if (error) {
        throw error;
      }
      return result;
    };


    /*
    Code BELOW was adapted FROM CoffeeScript's REPL:
      https://github.com/jashkenas/coffeescript/blob/master/src/repl.coffee
     */

    CafRepl.setupHistory = function(filename, maxSize) {
      if (filename == null) {
        filename = historyFile;
      }
      if (maxSize == null) {
        maxSize = historyMaxInputSize;
      }
      this.addHistoryListener(filename, maxSize);
      return this.addCommand({
        name: 'history',
        help: 'Show command history',
        action: (function(_this) {
          return function() {
            _this.cafRepl.outputStream.write((_this.cafRepl.history.slice(0).reverse().join('\n')) + "\n");
            return _this.cafRepl.displayPrompt();
          };
        })(this)
      });
    };

    CafRepl.loadHistory = function(filename, maxSize) {
      var buffer, lastLine, readFd, size, stat;
      lastLine = null;
      try {
        stat = fs.statSync(filename);
        size = Math.min(maxSize, stat.size);
        readFd = fs.openSync(filename, 'r');
        buffer = Buffer.alloc(size);
        fs.readSync(readFd, buffer, 0, size, stat.size - size);
        fs.closeSync(readFd);
        this.cafRepl.history = buffer.toString().split('\n').reverse();
        if (stat.size > maxSize) {
          this.cafRepl.history.pop();
        }
        if (this.cafRepl.history[0] === '') {
          this.cafRepl.history.shift();
        }
        this.cafRepl.historyIndex = -1;
        lastLine = this.cafRepl.history[0];
      } catch (error1) {}
      return lastLine;
    };

    CafRepl.addHistoryListener = function(filename, maxSize) {
      var fd, lastLine;
      fd = fs.openSync(filename, 'a');
      lastLine = this.loadHistory(filename, maxSize);
      this.cafRepl.addListener('line', function(code) {
        if (code && code.length && code !== '.history' && code !== '.exit' && lastLine !== code) {
          fs.writeSync(fd, code + "\n");
          return lastLine = code;
        }
      });
      return this.cafRepl.on('exit', function() {
        return fs.closeSync(fd);
      });
    };

    CafRepl.addCommand = function(arg) {
      var action, help, name;
      name = arg.name, help = arg.help, action = arg.action;
      return this.cafRepl.commands[name] = {
        help: help,
        action: action
      };
    };

    return CafRepl;

  })());

}).call(this);

//# sourceMappingURL=CafRepl.js.map
