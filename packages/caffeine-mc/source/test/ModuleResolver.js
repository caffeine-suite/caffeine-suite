// Generated by CoffeeScript 1.12.7
(function() {
  var WorkingCache, defineModule, each, findModule, findModuleSync, getNpmPackageName, isArray, log, merge, mockFs, ref, ref1,
    slice = [].slice;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, log = ref.log, each = ref.each, merge = ref.merge, isArray = ref.isArray;

  ref1 = Neptune.CaffeineMc, findModule = ref1.findModule, findModuleSync = ref1.findModuleSync, WorkingCache = ref1.WorkingCache, getNpmPackageName = ref1.getNpmPackageName;

  mockFs = require('mock-fs');

  defineModule(module, {
    suite: {
      findModule: function() {
        setup(function() {
          WorkingCache.resetWorkingCache();
          return CaffeineMcTestHelper.reset();
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'sub-awesome' in absolutePath.basename('" + file + "')", function() {
            if (/HurlockAlpha\.caf/.test(file)) {
              return assert.rejects(findModule("hurlock-alpha", {
                sourceFile: file
              }));
            } else {
              return findModule("hurlock-alpha", {
                sourceFile: file
              }).then(function(arg) {
                var absolutePath, requireString;
                requireString = arg.requireString, absolutePath = arg.absolutePath;
                assert.match(requireString, /\..*HurlockAlpha/, "requireString");
                return assert.match(absolutePath, /\/.*\/HurlockAlpha/, "absolutePath");
              });
            }
          });
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'sub-awesome/betaRelease' in absolutePath.basename('" + file + "')", function() {
            return findModule("sub-awesome/betaRelease", {
              sourceFile: file
            }).then(function(arg) {
              var absolutePath, requireString;
              requireString = arg.requireString, absolutePath = arg.absolutePath;
              assert.match(requireString, /\..*\/BetaRelease$/, "requireString");
              return assert.match(absolutePath, /\/.*\/SubAwesome\/BetaRelease$/, "absolutePath");
            });
          });
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'hurlock-alpha.caf' in absolutePath.basename('" + file + "')", function() {
            return findModule("hurlock-alpha.caf", {
              sourceFile: file
            }).then(function(arg) {
              var absolutePath, requireString;
              requireString = arg.requireString, absolutePath = arg.absolutePath;
              assert.match(requireString, /\.\/HurlockAlpha\.caf$/, "requireString");
              return assert.match(absolutePath, /DotCaffeineRoot\/HurlockAlpha\.caf$/, "absolutePath");
            });
          });
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'DotCaffeineRoot' in absolutePath.basename('" + file + "')", function() {
            return findModule("DotCaffeineRoot", {
              sourceFile: file
            }).then(function(arg) {
              var absolutePath, requireString;
              requireString = arg.requireString, absolutePath = arg.absolutePath;
              assert.match(requireString, /\.\/$/, "requireString");
              return assert.match(absolutePath, /DotCaffeineRoot$/, "absolutePath");
            });
          });
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'hurlock' in absolutePath.basename('" + file + "') should not match because it is only partial", function() {
            return assert.rejects(function() {
              return findModule("hurlock", {
                sourceFile: file
              });
            });
          });
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'DotCaffeineRootPeer.caf' in absolutePath.basename('" + file + "') should not match because it is a peer of the root", function() {
            return assert.rejects(function() {
              return findModule("DotCaffeineRootPeer.caf", {
                sourceFile: file
              });
            });
          });
        });
        each(CaffeineMcTestHelper.testFiles, function(file) {
          return test("'SourceRoots' in absolutePath.basename('" + file + "') should not match because it is the parent of the root", function() {
            return assert.rejects(function() {
              return findModule("SourceRoots", {
                sourceFile: file
              });
            });
          });
        });
        test("npm module", function() {
          return findModule("ArtStandardLib", {
            sourceDir: "."
          }).then(function(arg) {
            var absolutePath, requireString;
            requireString = arg.requireString, absolutePath = arg.absolutePath;
            assert.eq(requireString, "art-standard-lib");
            return assert.match(absolutePath, /art-standard-lib$/);
          });
        });
        return test("pathed npm module", function() {
          return findModule("ArtStandardLib/types", {
            sourceDir: "."
          }).then(function(arg) {
            var absolutePath, requireString;
            requireString = arg.requireString, absolutePath = arg.absolutePath;
            assert.eq(requireString, "art-standard-lib/Types");
            return assert.match(absolutePath, /art-standard-lib\/Types$/);
          });
        });
      },
      stubbedFindModule: function() {
        var dirReaderFromDirMap;
        setup(function() {
          return WorkingCache.resetWorkingCache();
        });
        teardown(function() {
          return mockFs.restore();
        });
        dirReaderFromDirMap = function(structure) {
          var find;
          find = function(dir, current) {
            var first, ref2, rest;
            if (current == null) {
              current = structure;
            }
            if (dir.length === 0) {
              return current;
            }
            ref2 = isArray(dir) ? dir : dir.split("/"), first = ref2[0], rest = 2 <= ref2.length ? slice.call(ref2, 1) : [];
            return find(rest, structure[first]);
          };
          return {
            dirReader: {
              read: function(dir) {
                var found;
                found = find(dir);
                if (!found) {
                  throw new Error("missing dir: " + dir);
                }
                return Object.keys(found);
              },
              isDir: function(dir) {
                return !!find(dir);
              },
              resolve: function(dir) {
                return dir;
              }
            }
          };
        };
        test("stubbed", function() {
          mockFs({
            ArtStandardLib: {
              alpha: {},
              beta: {}
            }
          });
          return findModule("ALPHA", merge({
            sourceDir: "ArtStandardLib/beta",
            sourceRoot: "ArtStandardLib"
          })).then(function(arg) {
            var absolutePath, requireString;
            requireString = arg.requireString, absolutePath = arg.absolutePath;
            assert.eq(requireString, "../alpha");
            return assert.match(absolutePath, "ArtStandardLib/alpha");
          });
        });
        test("MyDottedDir finds My.DottedDir", function() {
          mockFs({
            myRoot: {
              "My.DottedDir": {
                MySubdir: {}
              }
            }
          });
          return findModule("MyDottedDir", merge({
            sourceDir: "myRoot/My.DottedDir/MySubdir",
            sourceRoot: "myRoot"
          })).then(function(arg) {
            var absolutePath, requireString;
            requireString = arg.requireString, absolutePath = arg.absolutePath;
            return assert.eq(requireString, "../");
          });
        });
        test("DottedDir does not find My.DottedDir", function() {
          mockFs({
            myRoot: {
              "My.DottedDir": {
                MySubdir: {}
              },
              MyDottedDir: {}
            }
          });
          return assert.rejects(findModule("DottedDir", merge({
            sourceDir: "myRoot/My.DottedDir/MySubdir",
            sourceRoot: "myRoot"
          }))).then(function(rejectsWith) {
            return assert.match(rejectsWith.message, /Could not find.*DottedDir/i);
          });
        });
        return test("findModuleSync does not resolve to the sourceFile the request came from", function() {
          var found;
          mockFs({
            myRoot: {
              MySubdir: {
                "StandardImport.caf": "&StandardImport"
              },
              "StandardImport.caf": "&ArtSuite"
            }
          });
          found = findModuleSync("StandardImport", {
            sourceDir: "myRoot/MySubdir",
            sourceFile: "StandardImport.caf",
            sourceRoot: "myRoot"
          });
          assert.eq(found.requireString, "../StandardImport");
          return assert.isString(log(found.absolutePath));
        });

        /* regressions to test:
          &testing/testingMin >> testing/testing-min.js
          should become:
          &testing/build/testing-min
        
        - &ArtSuite
          should NOT resolve a parent directory named: Art.Suite.Demos
        - &indexeddb-promised
          should resolve to 'indexeddb-promised'
          even though the actual file is: indexeddb-promised/js/indexeddb-promised.js
         */
      },
      regressions: function() {
        test('getNpmPackageName', function() {
          return assert.eq(getNpmPackageName('three', ['build', 'three.min']), {
            requireString: "three",
            absolutePath: require.resolve("three/build/three.min").split(/\/build/)[0]
          });
        });
        return test("findModuleSync 'three/build/threeMin' - should return same as require.resolve", function() {
          return assert.eq({
            requireString: "three/build/three.min",
            absolutePath: require.resolve("three/build/three.min").split(/\.js$/)[0]
          }, findModuleSync("three/build/threeMin"));
        });
      }
    }
  });

}).call(this);
