// Generated by CoffeeScript 1.12.7
(function() {
  var ChainedTest, CompileCache, FileCompiler, SourceRoots, WorkingCache, fs, initialFs, log, merge, mockFs, obj, obj1, objectWithout, path, ref, ref1, sourceFile, sourceFileExtension, sourceFileName, sourcePath, sourceRoot, sourceRootName;

  ref = require('art-standard-lib'), merge = ref.merge, log = ref.log, objectWithout = ref.objectWithout;

  ref1 = Neptune.CaffeineMc, SourceRoots = ref1.SourceRoots, CompileCache = ref1.CompileCache, FileCompiler = ref1.FileCompiler, WorkingCache = ref1.WorkingCache;

  mockFs = require('mock-fs');

  fs = require('fs-extra');

  ChainedTest = require('art-testbench').ChainedTest;

  require("caffeine-script");

  require("art-standard-lib/Core");

  path = require('path');

  sourceRootName = "AliceInLove";

  sourceRoot = "/home/alice/" + sourceRootName;

  sourcePath = sourceRoot + "/source/AliceInLove/Lib";

  sourceFileName = "myFile";

  sourceFileExtension = "caf";

  sourceFile = sourcePath + "/" + sourceFileName + "." + sourceFileExtension;

  initialFs = (
    obj = {},
    obj["" + sourceRoot] = {
      "package.json": "{}",
      source: {
        AliceInLove: {
          Lib: (
            obj1 = {},
            obj1[sourceFileName + ".caf"] = "&standard_import",
            obj1
          ),
          "StandardImport.caf": ":foo"
        }
      }
    },
    obj
  );

  module.exports = {
    suite: {
      basic: function() {
        var fakeInfo;
        setup(function() {
          return mockFs(initialFs);
        });
        teardown(function() {
          return mockFs.restore();
        });
        fakeInfo = {
          compiler: {
            name: "TestCompiler",
            version: "1.2.3"
          },
          source: "My source code.",
          sourceFile: sourceFile,
          compiled: {
            js: "console.log('My source code'.);"
          }
        };
        test("getFileName", function() {
          var fn;
          fn = CompileCache.getFileName(fakeInfo);
          assert.match(fn, CompileCache.compileCacheFileNameRoot);
          assert.match(fn, "TestCompiler");
          assert.match(fn, sourceRootName);
          assert.match(fn, sourceFileName);
          return assert.match(fn, sourceFileExtension);
        });
        test("cache", function() {
          CompileCache.cache(fakeInfo);
          return assert.eq(fakeInfo.compiled, CompileCache.fetch(objectWithout(fakeInfo, "compiled")).compiled);
        });
        test("different compilerOptions generates different cache filenames", function() {
          return assert.neq(CompileCache.getFileName(merge(fakeInfo, {
            compilerOptions: {}
          })), CompileCache.getFileName(merge(fakeInfo, {
            compilerOptions: {
              transpile: true
            }
          })));
        });
        return test("compilerOptions with different order still generates same cache filenames", function() {
          return assert.eq(CompileCache.getFileName(merge(fakeInfo, {
            compilerOptions: {
              a: 1,
              b: 2
            }
          })), CompileCache.getFileName(merge(fakeInfo, {
            compilerOptions: {
              b: 2,
              a: 1
            }
          })));
        });
      },
      FileCompiler: function() {
        suiteSetup(function() {
          return mockFs(initialFs);
        });
        suiteTeardown(function() {
          return mockFs.restore();
        });
        setup(function() {
          return WorkingCache.resetWorkingCache();
        });
        return ChainedTest.setup().thenTest("initial", function() {
          return FileCompiler.compileFile(sourceFile, {
            cache: true
          }).then(function(arg) {
            var output;
            output = arg.output;
            return assert.jsFalse(output.fromCache);
          });
        }).thenTest("cached", function() {
          return FileCompiler.compileFile(sourceFile, {
            cache: true
          }).then(function(arg) {
            var output;
            output = arg.output;
            return assert["true"](output.fromCache);
          });
        }).thenTest("move moduleDependency triggers recompile", function() {
          var outputFilename;
          outputFilename = path.join(path.dirname(sourceFile), "StandardImport.caf");
          return fs.writeFile(outputFilename, ":bar").then(function() {
            WorkingCache.resetWorkingCache();
            return FileCompiler.compileFile(sourceFile, {
              cache: true
            });
          }).then(function(arg) {
            var output;
            output = arg.output;
            return assert.jsFalse(output.fromCache);
          });
        });
      }
    }
  };

}).call(this);
