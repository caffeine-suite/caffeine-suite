"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "beforeAll", "CaffeineMcTestHelper", "fs", "initialFs", "test", "assert", "findModule", "beforeEach", "WorkingCache", "isArray", "Error", "Object", "merge", "findModuleSync"], [global, require('./StandardImport'), require('./CaffeineMcTestHelper'), {fs: require('fs-extra')}], (describe, beforeAll, CaffeineMcTestHelper, fs, initialFs, test, assert, findModule, beforeEach, WorkingCache, isArray, Error, Object, merge, findModuleSync) => {return describe({findModule: function() {beforeAll(() => fs.setMockFileStructure(initialFs)); Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'sub-awesome' in absolutePath.basename('${Caf.toString(file)}')`, () => /HurlockAlpha\.caf/.test(file) ? assert.rejects(findModule("hurlock-alpha", {sourceFile: file})) : findModule("hurlock-alpha", {sourceFile: file}).then(({requireString, absolutePath}) => {assert.match(requireString, /\..*HurlockAlpha/, "requireString"); return assert.match(absolutePath, /\/.*\/HurlockAlpha/, "absolutePath");}))); Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'sub-awesome/betaRelease' in absolutePath.basename('${Caf.toString(file)}')`, () => findModule("sub-awesome/betaRelease", {sourceFile: file}).then(({requireString, absolutePath}) => {assert.match(requireString, /\..*\/BetaRelease$/, "requireString"); return assert.match(absolutePath, /\/.*\/SubAwesome\/BetaRelease$/, "absolutePath");}))); Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'hurlock-alpha.caf' in absolutePath.basename('${Caf.toString(file)}')`, () => findModule("hurlock-alpha.caf", {sourceFile: file}).then(({requireString, absolutePath}) => {assert.match(requireString, /\.\/HurlockAlpha\.caf$/, "requireString"); return assert.match(absolutePath, /DotCaffeineRoot\/HurlockAlpha\.caf$/, "absolutePath");}))); Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'DotCaffeineRoot' in absolutePath.basename('${Caf.toString(file)}')`, () => findModule("DotCaffeineRoot", {sourceFile: file}).then(({requireString, absolutePath}) => {assert.match(requireString, /\.\/$/, "requireString"); return assert.match(absolutePath, /DotCaffeineRoot$/, "absolutePath");}))); Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'hurlock' in absolutePath.basename('${Caf.toString(file)}') should not match because it is only partial`, () => assert.rejects(() => findModule("hurlock", {sourceFile: file})))); Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'DotCaffeineRootPeer.caf' in absolutePath.basename('${Caf.toString(file)}') should not match because it is a peer of the root`, () => assert.rejects(() => findModule("DotCaffeineRootPeer.caf", {sourceFile: file})))); return Caf.each2(CaffeineMcTestHelper.testFiles, (file) => test(`'SourceRoots' in absolutePath.basename('${Caf.toString(file)}') should not match because it is the parent of the root`, () => assert.rejects(() => findModule("SourceRoots", {sourceFile: file}))));}, npmModules: function() {beforeAll(() => fs.unmockFs()); test("npm module", () => findModule("ArtStandardLib", {sourceDir: "."}).then(({requireString, absolutePath}) => {assert.eq(requireString, "art-standard-lib"); return assert.match(absolutePath, /art-standard-lib$/);})); test("pathed npm module", () => findModule("ArtStandardLib/types", {sourceDir: "."}).then(({requireString, absolutePath}) => {assert.eq(requireString, "art-standard-lib/Types"); return assert.match(absolutePath, /art-standard-lib\/Types$/);})); test("npm organization: @art-suite/cli", () => findModule("@art-suite/cli", {sourceDir: "."}).then(({requireString, absolutePath}) => {assert.eq(requireString, "@art-suite/cli"); return assert.match(absolutePath, /art-suite\/cli$/);})); return test("npm organization: @ArtSuite/cli", () => findModule("@ArtSuite/cli", {sourceDir: "."}).then(({requireString, absolutePath}) => {assert.eq(requireString, "@art-suite/cli"); return assert.match(absolutePath, /art-suite\/cli$/);}));}, stubbedFindModule: function() {let dirReaderFromDirMap; beforeEach(() => {WorkingCache.resetWorkingCache(); return fs.setMockFileStructure(initialFs);}); dirReaderFromDirMap = (structure) => {let findDir; findDir = (dir, current = structure) => {let first, rest; if (dir.length === 0) {return current;}; ([first, ...rest] = isArray(dir) ? dir : dir.split("/")); return findDir(rest, structure[first]);}; return {dirReader: {read: (dir) => {let found; found = findDir(dir); if (!found) {throw new Error(`missing dir: ${Caf.toString(dir)}`);}; return Object.keys(found);}, isDir: (dir) => !!findDir(dir), resolve: (dir) => dir}};}; test("stubbed", () => {fs.setMockFileStructure({ArtStandardLib: {alpha: {}, beta: {}}}); return findModule("ALPHA", merge({sourceDir: "ArtStandardLib/beta", sourceRoot: "ArtStandardLib"})).then(({requireString, absolutePath}) => {assert.eq(requireString, "../alpha"); return assert.match(absolutePath, "ArtStandardLib/alpha");});}); test("MyDottedDir finds My.DottedDir", () => {fs.setMockFileStructure({myRoot: {"My.DottedDir": {MySubdir: {}}}}); return findModule("MyDottedDir", merge({sourceDir: "myRoot/My.DottedDir/MySubdir", sourceRoot: "myRoot"})).then(({requireString, absolutePath}) => assert.eq(requireString, "../"));}); test("DottedDir does not find My.DottedDir", () => {fs.setMockFileStructure({myRoot: {"My.DottedDir": {MySubdir: {}}, MyDottedDir: {}}}); return assert.rejects(findModule("DottedDir", merge({sourceDir: "myRoot/My.DottedDir/MySubdir", sourceRoot: "myRoot"}))).then((rejectsWith) => assert.match(rejectsWith.message, /Could not find.*DottedDir/i));}); return test("findModuleSync does not resolve to the sourceFile the request came from", () => {let found; fs.setMockFileStructure({myRoot: {MySubdir: {"StandardImport.caf": "&StandardImport"}, "StandardImport.caf": "&ArtSuite"}}); found = findModuleSync("StandardImport", {sourceDir: "myRoot/MySubdir", sourceFile: "StandardImport.caf", sourceRoot: "myRoot"}); assert.eq(found.requireString, "../StandardImport"); return assert.isString(found.absolutePath);});}});});});
//# sourceMappingURL=ModuleResolver.test.js.map
