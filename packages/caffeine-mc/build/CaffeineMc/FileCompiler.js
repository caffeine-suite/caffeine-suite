"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Error", "path", "findSourceRootSync", "getCaffeineInitSync", "fs", "merge", "Promise", "findSourceRoot", "getCaffeineInit", "present", "log"], [global, require('./StandardImport'), require('./SourceRoots')], (Error, path, findSourceRootSync, getCaffeineInitSync, fs, merge, Promise, findSourceRoot, getCaffeineInit, present, log) => {let CaffeineMc, FileCompiler; CaffeineMc = require("./namespace"); return FileCompiler = Caf.defClass(class FileCompiler extends Object {}, function(FileCompiler, classSuper, instanceSuper) {this.compileFileSync = function(sourceFile, options = {}) {let source, sourceRoot, compiler, config; if (options.outputDirectory) {throw new Error("outputDirectory unsupported");}; source = options.source; sourceRoot = options.sourceRoot; sourceRoot = sourceRoot ? path.resolve(sourceRoot) : findSourceRootSync(sourceFile); ({compiler, config} = getCaffeineInitSync(sourceRoot)); source != null ? source : source = fs.readFileSync(sourceFile).toString(); return compiler.compile(source, merge(config, options, {sourceFile, sourceRoot}));}; this.compileFile = function(sourceFile, options = {}) {let outputDirectory, source, sourceRoot, result; outputDirectory = options.outputDirectory; source = options.source; sourceRoot = options.sourceRoot; result = {readCount: 0, writeCount: 0, unchangedCount: 0, outputFiles: [], output: null}; return Promise.all([sourceRoot ? path.resolve(sourceRoot) : findSourceRoot(sourceFile), fs.exists(sourceFile).then((exists) => !exists ? (() => {throw new Error(`sourceFile not found: ${Caf.toString(sourceFile)}`);})() : undefined)]).then(([sourceRoot]) => Promise.all([getCaffeineInit(sourceRoot), source != null ? source : Promise.then(() => fs.readFile(sourceFile).then((source) => source.toString())).tap(() => result.readCount++)]).then(([{compiler, config}, source]) => compiler.compile(source, merge(config, options, {sourceFile, sourceRoot})))).then((compilerResult) => {let compiled, basename; ({compiled} = result.output = compilerResult); return outputDirectory ? (basename = path.basename(sourceFile, path.extname(sourceFile)), Promise.all(Caf.array(compiled, (text, extension) => {let outputFilename; result.outputFiles.push(outputFilename = path.join(outputDirectory, `${Caf.toString(basename)}.${Caf.toString(extension)}`)); return Promise.then(() => fs.readFile(outputFilename).then((existing) => existing.toString()).catch(() => null)).then((existingData) => (existingData !== text) ? fs.writeFile(outputFilename, text).then(() => result.writeCount++) : result.unchangedCount++);}, (text, extension) => present(text)))) : undefined;}).then(() => result).catch((e) => {log.error(`error compiling: ${Caf.toString(sourceFile)}`); return (() => {throw e;})();});};});});});
//# sourceMappingURL=FileCompiler.js.map
