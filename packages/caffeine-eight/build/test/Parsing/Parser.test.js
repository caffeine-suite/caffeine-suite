"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Parser", "assert", "wordsArray", "Node"], [global, require('../StandardImport')], (describe, test, Parser, assert, wordsArray, Node) => {return describe({basic: function() {test('a "\'foo\'"', () => {let MyParser, myParser, result; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "'foo'"});}); myParser = new MyParser; result = myParser.parse("foo"); assert.eq(result.offset, 0); assert.eq(result.matchLength, 3); return assert.eq(result.text, "foo");}); test("/foo/", () => {let MyParser, myParser, result; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: /foo/});}); myParser = new MyParser; result = myParser.parse("foo"); assert.eq(result.offset, 0); assert.eq(result.matchLength, 3); return assert.eq(result.text, "foo");}); test("/[0-9]+/", () => {let MyParser, sources; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: /[0-9]+/});}); return Caf.each2(sources = wordsArray("0 1 10 123 1001"), (source) => {let result; result = MyParser.parse(source); assert.eq(result.offset, 0); assert.eq(result.matchLength, source.length); return assert.eq(result.text, source);});}); return test("match /[0-9]+/ -- doesn't match if not at the start of the string", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({foo: /[0-9]+/});}); return assert.throws(() => MyParser.parse(" 0123"));});}, "sequence parsing": function() {test("'foo' /bar/", () => {let MyParser, myParser, result; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "'foo' /bar/"});}); myParser = new MyParser; result = myParser.parse("foobar"); assert.eq(result.offset, 0); assert.eq(result.matchLength, 6); return assert.eq(result.text, "foobar");}); test("/foo/ /bar/", () => {let MyParser, myParser, result; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "/foo/ /bar/"});}); myParser = new MyParser; result = myParser.parse("foobar"); assert.eq(result.offset, 0); assert.eq(result.matchLength, 6); return assert.eq(result.text, "foobar");}); return test("/foo/ bar", () => {let MyParser, myParser, result; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "/foo/ bar", bar: /bar/});}); myParser = new MyParser; result = myParser.parse("foobar"); assert.eq(result.offset, 0); assert.eq(result.matchLength, 6); return assert.eq(result.text, "foobar");});}, "conditional parsing": function() {test("conditional rule 'foo? bar'", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "foo? bar", bar: /bar/, foo: /foo/});}); MyParser.parse("bar"); return MyParser.parse("foobar");}); return test("conditional regExp '/foo/? bar'", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "/foo/? bar", bar: /bar/});}); MyParser.parse("bar"); return MyParser.parse("foobar");});}, "negative parsing": function() {return test("!boo anything", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "!boo anything", boo: /boo/, anything: /.*/});}); assert.throws(() => MyParser.parse("boo")); assert.throws(() => MyParser.parse("boobat")); return MyParser.parse("bobat");});}, "couldMatch parsing": function() {return test("couldMatch: 'boo &foo rest'", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "boo &foo rest", boo: /boo/, foo: /foo/, rest: /fo[a-z]+/});}); MyParser.parse("boofoo"); return assert.throws(() => MyParser.parse("boofoa"));});}, "rule variants": function() {return test("two variants", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: /boo/}); this.rule({root: /foo/});}); MyParser.parse("boo"); return MyParser.parse("foo");});}, "many parsing": function() {test("boo*", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "boo*", boo: /boo/});}); MyParser.parse(""); MyParser.parse("boo"); return MyParser.parse("booboo");}); return test("boo+", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "boo+", boo: /boo/});}); assert.throws(() => MyParser.parse("")); MyParser.parse("boo"); return MyParser.parse("booboo");});}, "custom parser": function() {test("basic", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: {parse: function(parentNode) {let nextOffset, source; ({nextOffset, source} = parentNode); return (source[nextOffset] === "a") ? new Node(parentNode, {offset: nextOffset, matchLength: 1, ruleVariant: this}) : undefined;}}});}); MyParser.parse("a"); return assert.throws(() => MyParser.parse("A"));}); return test("alternate custom parsers", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: [{parse: function(parentNode) {let nextOffset, source; ({nextOffset, source} = parentNode); return (source[nextOffset] === "a") ? new Node(parentNode, {offset: nextOffset, matchLength: 1, ruleVariant: this}) : undefined;}}, {parse: function(parentNode) {let nextOffset, source; ({nextOffset, source} = parentNode); return (source[nextOffset] === "b") ? new Node(parentNode, {offset: nextOffset, matchLength: 1, ruleVariant: this}) : undefined;}}]});}); MyParser.parse("a"); MyParser.parse("b"); return assert.throws(() => MyParser.parse("A"));});}, "prevent simple infinite loops": function() {test("/foo/ /$/*", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "/foo/ /$/*"});}); return MyParser.parse("foo");}); return test("/foo/ /$/+", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "/foo/ /$/+"});}); return MyParser.parse("foo");});}, multiNotations: function() {test("rule root: []", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: [/foo/, /boo/]});}); MyParser.parse("foo"); return MyParser.parse("boo");}); test("rule root: [..., {}]", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: [/foo/, /boo/, {custom: function() {return this.text.toUpperCase();}}]});}); assert.eq("FOO", MyParser.parse("foo").custom()); return assert.eq("BOO", MyParser.parse("boo").custom());}); return test("rule root: pattern: [], ...", () => {let MyParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: {pattern: [/foo/, /boo/], custom: function() {return this.text.toUpperCase();}}});}); assert.eq("FOO", MyParser.parse("foo").custom()); return assert.eq("BOO", MyParser.parse("boo").custom());});}});});});
//# sourceMappingURL=Parser.test.js.map
