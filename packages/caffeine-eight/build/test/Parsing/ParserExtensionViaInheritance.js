// Generated by CoffeeScript 1.12.7
(function() {
  var Node, Nodes, Parser, log, ref, ref1, wordsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Neptune.Art.StandardLib, log = ref.log, wordsArray = ref.wordsArray;

  ref1 = Neptune.Caffeine.Eight, Parser = ref1.Parser, Nodes = ref1.Nodes;

  Node = Nodes.Node;

  module.exports = {
    suite: {
      basic: function() {
        var MyParser, MySubParser;
        MyParser = MySubParser = null;
        setup(function() {
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "'foo'"
            });

            return MyParser;

          })(Parser);
          return MySubParser = (function(superClass) {
            extend(MySubParser, superClass);

            function MySubParser() {
              return MySubParser.__super__.constructor.apply(this, arguments);
            }

            MySubParser.rule({
              root: "'bar'"
            });

            return MySubParser;

          })(MyParser);
        });
        test("parsers are extensible", function() {
          var myParser;
          myParser = new MySubParser;
          myParser.parse("bar");
          return myParser.parse("foo");
        });
        test("parsers extentension doesn't alter parent class", function() {
          var myParser1, myParser2;
          myParser1 = new MyParser;
          myParser2 = new MySubParser;
          assert.throws(function() {
            return myParser1.parse("bar");
          });
          return assert["true"](!!myParser2.parse("bar"));
        });
        return test("can add rules from instance", function() {
          var myParser, result;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "'foo'"
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          myParser.rule({
            root: "'bar'"
          });
          result = myParser.parse("bar");
          assert.eq(result.offset, 0);
          assert.eq(result.matchLength, 3);
          return assert.eq(result.text, "bar");
        });
      },
      priorityRule: function() {
        return test("parsers are extensible", function() {
          var MyNormalSubParser, MyParser, MyPrioritySubParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "'foo' 'o'?"
            });

            return MyParser;

          })(Parser);
          MyNormalSubParser = (function(superClass) {
            extend(MyNormalSubParser, superClass);

            function MyNormalSubParser() {
              return MyNormalSubParser.__super__.constructor.apply(this, arguments);
            }

            MyNormalSubParser.rule({
              root: "'fooo'"
            });

            return MyNormalSubParser;

          })(MyParser);
          MyPrioritySubParser = (function(superClass) {
            extend(MyPrioritySubParser, superClass);

            function MyPrioritySubParser() {
              return MyPrioritySubParser.__super__.constructor.apply(this, arguments);
            }

            MyPrioritySubParser.priorityRule({
              root: "'fooo'"
            });

            return MyPrioritySubParser;

          })(MyParser);
          assert.eq(2, (new MyParser).parse("fooo").matches.length, "MyParser");
          assert.eq(2, (new MyNormalSubParser).parse("fooo").matches.length, "MyNormalSubParser");
          return assert.eq(1, (new MyPrioritySubParser).parse("fooo").matches.length, "MyPrioritySubParser");
        });
      },
      replaceRule: function() {
        return test("parsers are extensible", function() {
          var MyParser, MyReplaceSubParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: /foo/
            });

            return MyParser;

          })(Parser);
          MyReplaceSubParser = (function(superClass) {
            extend(MyReplaceSubParser, superClass);

            function MyReplaceSubParser() {
              return MyReplaceSubParser.__super__.constructor.apply(this, arguments);
            }

            MyReplaceSubParser.replaceRule({
              root: /bar/
            });

            return MyReplaceSubParser;

          })(MyParser);
          (new MyParser).parse("foo");
          assert.throws(function() {
            return (new MyParser).parse("bar");
          });
          (new MyReplaceSubParser).parse("bar");
          return assert.throws(function() {
            return (new MyReplaceSubParser).parse("foo");
          });
        });
      }
    }
  };

}).call(this);

//# sourceMappingURL=ParserExtensionViaInheritance.js.map
