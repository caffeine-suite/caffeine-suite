"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "assert", "CaffeineEightCompileError", "test", "Parser", "Object", "w"], [global, require('../StandardImport')], (describe, assert, CaffeineEightCompileError, test, Parser, Object, w) => {let validateCompileError, validateCompileError2; validateCompileError = function(error, testProps) {assert.instanceof(CaffeineEightCompileError, error); assert.selectedPropsEq(testProps, error); return assert.match(error.message, /<HERE>/);}; validateCompileError2 = function(parser, text, testedProps) {let myParser; myParser = new parser; return assert.rejects(() => myParser.parse(text)).then((error) => {assert.instanceof(CaffeineEightCompileError, error); assert.selectedPropsEq(testedProps, error); return assert.match(error.message, /<HERE>/);});}; return describe({info: function() {let getClass; getClass = () => {let MyParser; return MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "myRule+", myRule: /foo\n?/});});}; test("baseline ok", () => {let MyParser, myParser; MyParser = getClass(); myParser = new MyParser; return myParser.parse("foo");}); test("0", () => {let MyParser, myParser; MyParser = getClass(); myParser = new MyParser; return assert.rejects(() => myParser.parse("bad")).then((error) => validateCompileError(error, {failureIndex: 0, line: 0, column: 0}));}); test("line 1, col 3", () => {let MyParser, myParser; MyParser = getClass(); myParser = new MyParser; return assert.rejects(() => myParser.parse("foobad")).then((error) => validateCompileError(error, {failureIndex: 3, line: 0, column: 3, location: ":1:4"}));}); test("line 2, col 1", () => {let MyParser, myParser; MyParser = getClass(); myParser = new MyParser; return assert.rejects(() => myParser.parse("foo\nbad")).then((error) => validateCompileError(error, {failureIndex: 4, line: 1, column: 0}));}); return test("line 2, col 4", () => {let MyParser, myParser; MyParser = getClass(); myParser = new MyParser; return assert.rejects(() => myParser.parse("foo\nfoobar")).then((error) => validateCompileError(error, {failureIndex: 7, line: 1, column: 3}));});}, infoOnNonFirstPattern: function() {let getClass; getClass = () => {let MyParser; return MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "number _ /[a-z]+/", number: /[0-9]+/, _: /\s+/});});}; test("baseline", () => {let MyParser; MyParser = getClass(); return MyParser.parse("1 hi");}); test("fail on first pattern", () => {let MyParser; MyParser = getClass(); return validateCompileError2(MyParser, "- hi", {failureIndex: 0, line: 0, column: 0, expectingInfo: {expecting: {"/[0-9]+/": {"to-continue": "root", "started-at": "1:1"}}}});}); return test("fail on second pattern", () => {let MyParser; MyParser = getClass(); return validateCompileError2(MyParser, "1 HI", {failureIndex: 2, line: 0, column: 2, expectingInfo: {expecting: {"/[a-z]+/": {"to-continue": "root", "started-at": "1:1"}}}});});}, basic: function() {return test("no match at all simple", () => {let MyParser, myParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "foo", foo: "bar", bar: /bar/});}); myParser = new MyParser; return assert.rejects(() => myParser.parse("bad")).then((error) => {validateCompileError(error, {failureIndex: 0, line: 0, column: 0}); return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/"]);});});}, couldMatchKeys: function() {test("no match at all", () => {let MyParser, myParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "foo", foo: "bar? baz", bar: /bar/, baz: /baz/});}); myParser = new MyParser; return assert.rejects(() => myParser.parse("bad")).then((error) => {validateCompileError(error, {failureIndex: 0, line: 0, column: 0}); return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/", "BazRuleBazVariant: /baz/"]);});}); return test("partial match", () => {let MyParser, myParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "foo", foo: "duh? bar? baz", duh: /duh/, bar: /bar/, baz: /baz/});}); myParser = new MyParser; return assert.rejects(() => myParser.parse("duhbad")).then((error) => {validateCompileError(error, {failureIndex: 3, line: 0, column: 3}); return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/", "BazRuleBazVariant: /baz/"]);});});}, misc: function() {test("nonMatches keys", () => {let MyParser, myParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: w("foo bar baz"), foo: "'foo'", bar: /bar/, baz: '"baz"'});}); myParser = new MyParser; return assert.rejects(() => myParser.parse("bad")).then((error) => {validateCompileError(error, {failureIndex: 0, line: 0, column: 0}); return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/", 'BazRuleBazVariant: "baz"', "FooRuleFooVariant: 'foo'"]);});}); test("expectingInfo", () => {let MyParser, myParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "foobarbaz foobarbaz", foobarbaz: w("foo bar baz"), foo: "'foo'", bar: /bar/, baz: '"baz"'});}); myParser = new MyParser; return assert.rejects(() => myParser.parse("barfo")).then((error) => validateCompileError(error, {failureIndex: 3, line: 0, column: 3}));}); return test("matchingNegative", () => {let MyParser, myParser; MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "foobarbaz foobarbaz", foobarbaz: w("foo bar baz"), foo: "'foo'", bar: /bar/, baz: '!boo "baz"', boo: /boo/});}); myParser = new MyParser; return assert.rejects(() => myParser.parse("baz")).then((error) => validateCompileError(error, {failureIndex: 3, line: 0, column: 3}));});}});});});
//# sourceMappingURL=CouldHaveContinued.test.js.map
