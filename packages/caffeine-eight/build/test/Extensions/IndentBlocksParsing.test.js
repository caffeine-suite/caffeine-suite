"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "Parser", "Extensions", "w", "log", "Error", "compactFlatten", "beforeEach", "test", "assert"], [global, require('../StandardImport')], (describe, Parser, Extensions, w, log, Error, compactFlatten, beforeEach, test, assert) => {let createMyBlockParserClass, createMyBlockParser, createMyEolOrBlockParserClass, createMyEolOrBlockParser, createObjectNotationParser; createMyBlockParserClass = function() {let MyBlockParser; return MyBlockParser = Caf.defClass(class MyBlockParser extends Parser {}, function(MyBlockParser, classSuper, instanceSuper) {this.rule({root: "line+", line: [/!!!/, "end", "expression block? end"], expression: /[a-z0-9A-Z]+/, end: /\n|$/, block: Extensions.IndentBlocks.getPropsToSubparseBlock()});});}; createMyBlockParser = function() {let Parser; Parser = createMyBlockParserClass(); return new Parser;}; createMyEolOrBlockParserClass = function() {let MyEolOrBlockParser; return MyEolOrBlockParser = Caf.defClass(class MyEolOrBlockParser extends Parser {}, function(MyEolOrBlockParser, classSuper, instanceSuper) {this.rule({root: "expression block? end", expression: "/[a-z0-9A-Z]+/", end: "/\n|$/", block: Extensions.IndentBlocks.getPropsToSubparseToEolAndBlock()});});}; createMyEolOrBlockParser = function() {let Parser; Parser = createMyEolOrBlockParserClass(); return new Parser;}; createObjectNotationParser = function() {let ObjectNotationParser; return ObjectNotationParser = Caf.defClass(class ObjectNotationParser extends Parser {}, function(ObjectNotationParser, classSuper, instanceSuper) {this.nodeBaseClass = {toJs: function() {let m, from, into, to, i, temp; if (m = (from = this.matches, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let match; match = from[i]; if (match.toJs) {into = match; break;}; temp = i++;}; return temp;})()) : undefined, into)) {return m.toJs();}; log({"no matches have toJs": {self: this, class: this.class, matches: this.matches, parseTreePath: this.parseTreePath}}); return (() => {throw new Error("no matches have toJs");})();}}; this.rules({root: "statement+", block: Extensions.IndentBlocks.getPropsToSubparseBlock(), expression: w("object array block literal"), literal: {pattern: w("string number"), toJs: function() {return this.text;}}, end: ["block end", "/\n+|$/"], statement: ["objectStatement end", "expression end"], string: /"([^"]|\\.)*"/, number: /-?(\.[0-9]+|[0-9]+(\.[0-9]+)?)/, array: [{pattern: "'[]' block", toJs: function() {return `[${Caf.toString(Caf.array(this.block.statements, (node) => node.toJs()).join(", "))}]`;}}, {pattern: "'[]' _? arrayElementWithDelimiter* expression", toJs: function() {return `[${Caf.toString(Caf.array(compactFlatten([this.arrayElementWithDelimiters, this.expression]), (node) => node.toJs()).join(", "))}]`;}}, {pattern: "'[]'", toJs: function() {return this.text;}}], arrayElementWithDelimiter: "expression _? ',' _?", object: ["'{}' block", {pattern: "'{}'? _? objectPropList", toJs: function() {return (this.objectPropList || this.block).toJs();}}], objectStatement: {pattern: "objectProp objectPropLine*", toJs: function() {return `{${Caf.toString(Caf.array(compactFlatten([this.objectProp, this.objectPropLines]), (m) => m.toJs()).join(", "))}}`;}}, objectPropLine: {pattern: "end objectProp", toJs: function() {return this.objectProp.toJs();}}, objectPropList: {pattern: "objectProp objectPropListItem*", toJs: function() {return `{${Caf.toString(Caf.array(compactFlatten([this.objectProp, this.objectPropListItems]), (m) => m.toJs()).join(", "))}}`;}}, objectPropListItem: {pattern: '"," _? objectProp', toJs: function() {return this.objectProp.toJs();}}, objectProp: {pattern: "objectPropLabel _? colon _? expression", toJs: function() {return `${Caf.toString(this.objectPropLabel)}: ${Caf.toString(this.expression.toJs())}`;}}, commaOrEnd: ["',' _?", "end"], objectPropLabel: /[_a-zA-Z][_a-zA-Z0-9.]*/, colon: /\:/, _: /\ +/});});}; return describe({toEolSubparsing: function() {let MyParser; MyParser = null; beforeEach(() => MyParser = Caf.defClass(class MyParser extends Parser {}, function(MyParser, classSuper, instanceSuper) {this.rule({root: "line+", line: "linePart end", linePart: ["lineLabel lineEnd", "'(' linePart ')'"], end: "/\n|$/", lineEnd: Extensions.IndentBlocks.getPropsToSubparseToEol({rule: "word", allowPartialMatch: true}), lineLabel: /[0-9]+\: */, word: /[a-z]+/});})); test("simple expression", () => {MyParser.parse("1: hi"); return undefined;}); test("partial toEol match works", () => {MyParser.parse("(1: hi)"); return undefined;}); return test("extra nesting", () => {MyParser.parse("((1: hi))"); return undefined;});}, ifThenElseWithPartialSubBlocks: function() {let IfThenElseParser; IfThenElseParser = null; beforeEach(() => IfThenElseParser = Caf.defClass(class IfThenElseParser extends Parser {}, function(IfThenElseParser, classSuper, instanceSuper) {this.rule({root: [{pattern: "ifThenElse", toTestStructure: function() {return this.ifThenElse.toTestStructure();}}, {pattern: "words", toTestStructure: function() {return this.words.toTestStructure();}}], ifThenElse: {pattern: "/if/ _ testBody:expression _ /then/ _ thenBody:expression _ /else/ _ elseBody:expression", toTestStructure: function() {return {test: this.testBody.toTestStructure(), then: this.thenBody.toTestStructure(), else: this.elseBody.toTestStructure()};}}, expression: {pattern: Extensions.IndentBlocks.getPropsToSubparseToEol({rule: "words", allowPartialMatch: true}), toTestStructure: function() {return this.matches[0].toTestStructure();}}, words: {pattern: "word*", toTestStructure: function() {return Caf.array(this.words, (word) => word.toString().trim());}}, word: "_? !/(if|then|else)\\b/ /[a-z]+/", _: /\ +/});})); test("simple words", () => {IfThenElseParser.parse("hi there"); return undefined;}); test("simple if-then-else", () => {IfThenElseParser.parse("if a then b else c"); return undefined;}); return test("more if-then-else", () => {let result; result = IfThenElseParser.parse("if a b then c d else e f"); return assert.eq(result.toTestStructure(), {test: ["a", "b"], then: ["c", "d"], else: ["e", "f"]});});}, absoluteOffset: function() {let MyBlockParser, validateAbsoluteOffsets; MyBlockParser = null; beforeEach(() => MyBlockParser = Caf.defClass(class MyBlockParser extends Parser {}, function(MyBlockParser, classSuper, instanceSuper) {this.rule({root: "line+", line: ["end", "expression block? end"], expression: "/[a-z0-9A-Z]+/", end: "/\n|$/", block: Extensions.IndentBlocks.getPropsToSubparseBlock()});})); validateAbsoluteOffsets = (node) => {let absoluteOffset, sourceValue; ({absoluteOffset} = node); if (node.ruleName === "expression") {sourceValue = node.toString(); assert.eq(absoluteOffset, node.parser.rootSource.indexOf(sourceValue), {sourceValue});}; Caf.each2(node.children, (child) => assert.lte(absoluteOffset, validateAbsoluteOffsets(child), {message: "parent node's absoluteOffset should be <= all of its children", node: node.toString(), child: child.toString()})); return absoluteOffset;}; test("simple", () => {validateAbsoluteOffsets(MyBlockParser.parse("alpha")); return undefined;}); test("one block", () => {validateAbsoluteOffsets(MyBlockParser.parse("alpha\n  beautlful\n  colorful")); return undefined;}); return test("nested blocks", () => {let p; validateAbsoluteOffsets(p = MyBlockParser.parse("alpha\n  beautlful\n  colorful\n    and\n    delightful")); return undefined;});}, blockParsing: {basic: function() {test("simple expression", () => {createMyBlockParserClass().parse("one"); return undefined;}); test("one block", () => {createMyBlockParserClass().parse("one\n  two"); return undefined;}); return test("nested blocks", () => {createMyBlockParserClass().parse("one\n  two\n    three"); return undefined;});}, failure_location: {baseline_without_block: function() {test("before first line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("-abc")).then((rejectsWith) => {log({rejectsWith, parser, parse: parser.parse}); return assert.eq(parser._failureIndex, 0);});}); test("first line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc-")).then((rejectsWith) => assert.eq(parser._failureIndex, 3));}); return test("second line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc\nfoo-")).then((rejectsWith) => assert.eq(parser._failureIndex, 7));});}, in_block: function() {test("before line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc\n  -def\n  foos")).then((rejectsWith) => assert.eq(parser._failureIndex, 6));}); test("first line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc\n  def-\n  foos")).then((rejectsWith) => assert.eq(parser._failureIndex, 9));}); return test("second line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc\n  def\n  foos-")).then((rejectsWith) => assert.eq(parser._failureIndex, 16));});}, in_nested_block: function() {test("first line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc\n  def\n    dood-\n  foos")).then((rejectsWith) => assert.eq(parser._failureIndex, 18));}); return test("second line", () => {let parser; parser = createMyBlockParser(); return assert.rejects(() => parser.parse("abc\n  def2\n    dood\n    goof-\n  foos")).then((rejectsWith) => assert.eq(parser._failureIndex, 28));});}}}, eolOrBlockParsing: {basics: function() {test("simple expression", () => {createMyEolOrBlockParserClass().parse("one"); return undefined;}); test("simple block", () => {createMyEolOrBlockParserClass().parse("one\n  two"); return undefined;}); test("simple eol", () => {createMyEolOrBlockParserClass().parse("one two"); return undefined;}); test("nested blocks", () => {createMyEolOrBlockParserClass().parse("one\n  two\n    three"); return undefined;}); test("nested eols", () => {createMyEolOrBlockParserClass().parse("one two three"); return undefined;}); return test("nested eols and blocks", () => {createMyEolOrBlockParserClass().parse("one two\n  three"); return undefined;});}, failure_location: function() {test("in EOL content", () => {let parser; parser = createMyEolOrBlockParser(); return assert.rejects(() => parser.parse("one -two")).then((rejectsWith) => assert.eq(parser._failureIndex, 4));}); test("in block with EOL content", () => {let parser; parser = createMyEolOrBlockParser(); return assert.rejects(() => parser.parse("one two\n  -abc")).then((rejectsWith) => assert.eq(parser._failureIndex, 10));}); return test("in block without EOL content", () => {let parser; parser = createMyEolOrBlockParser(); return assert.rejects(() => parser.parse("one\n  -abc")).then((rejectsWith) => assert.eq(parser._failureIndex, 6));});}}, CaffeineScriptObjectNotation: {"parsing literals": function() {test("string expression", () => {createObjectNotationParser().parse('"hi"'); return undefined;}); return test("number expression", () => {createObjectNotationParser().parse(".1"); createObjectNotationParser().parse("0.1"); createObjectNotationParser().parse("0"); createObjectNotationParser().parse("-100"); return undefined;});}, "parsing objects": function() {test("one line", () => {createObjectNotationParser().parse("hi:123"); createObjectNotationParser().parse("hi:123, bye:345"); return undefined;}); test("object expression", () => {createObjectNotationParser().parse("hi:123"); createObjectNotationParser().parse("hi:    123\nthere: 456"); createObjectNotationParser().parse("{}\n  hi:    123\n  there: 456"); return undefined;}); return test("nested object expression", () => {createObjectNotationParser().parse("hi:    123\nthere:\n  one: 123\n  two: 456"); return undefined;});}, "parsing arrays": function() {return test("array", () => {createObjectNotationParser().parse("[]"); createObjectNotationParser().parse("[] 1"); createObjectNotationParser().parse("[]\n  1"); return undefined;});}, "toJs literals": function() {return test("string expression", () => assert.eq(createObjectNotationParser().parse('"hi"').toJs(), '"hi"'));}, "toJs objects": function() {test("simple", () => assert.eq(createObjectNotationParser().parse("hi: 123").toJs(), "{hi: 123}")); test("object expression implicit one-liner", () => assert.eq(createObjectNotationParser().parse("hi: 123, bye:456").toJs(), "{hi: 123, bye: 456}")); test("object expression explicit one-liner", () => assert.eq(createObjectNotationParser().parse("{} hi: 123, bye:456").toJs(), "{hi: 123, bye: 456}")); test("object statement", () => {let p; p = createObjectNotationParser().parse('foo: 123\nbar: "hi"\nbaz: .1'); return assert.eq(p.toJs(), '{foo: 123, bar: "hi", baz: .1}');}); test("object statement with nested object expression", () => {let p; p = createObjectNotationParser().parse("foo: bar: 123\nbaz: 456"); return assert.eq(p.toJs(), "{foo: {bar: 123}, baz: 456}");}); test("nested object statements", () => {let parsed; parsed = createObjectNotationParser().parse("foo: 123\nbar:\n  baz: 2\n  bud: 3"); return assert.eq(parsed.toJs(), "{foo: 123, bar: {baz: 2, bud: 3}}");}); return test("nested object expression one line", () => assert.eq(createObjectNotationParser().parse("foo: 123\nbar: baz: 2, bud: 3").toJs(), "{foo: 123, bar: {baz: 2, bud: 3}}"));}, "toJs array": function() {return test("array", () => {assert.eq(createObjectNotationParser().parse("[]").toJs(), "[]"); assert.eq(createObjectNotationParser().parse("[] 1").toJs(), "[1]"); assert.eq(createObjectNotationParser().parse("[] 1, 2").toJs(), "[1, 2]"); return assert.eq(createObjectNotationParser().parse("[]\n  123\n  456").toJs(), "[123, 456]");});}, "toJs complex": function() {return test("everything", () => assert.eq(createObjectNotationParser().parse('myNumber1: .10\nmyNumber2: 1\nmyNumber3: 1.1\n\nmyArray1: []\n  123\n  456\nmyArray2: [] "hello", "world"\n\nmyObject1: foo: 1, bar: 2\nmyObject2: {} foo: 1, bar: 2').toJs(), '{myNumber1: .10, myNumber2: 1, myNumber3: 1.1, myArray1: [123, 456], myArray2: [\"hello\", \"world\"], myObject1: {foo: 1, bar: 2}, myObject2: {foo: 1, bar: 2}}'));}}});});});
//# sourceMappingURL=IndentBlocksParsing.test.js.map
