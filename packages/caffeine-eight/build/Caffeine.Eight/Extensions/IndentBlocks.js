// Generated by CoffeeScript 1.12.7
(function() {
  var Node, array, defineModule, escapeJavascriptString, find, log, merge, ref;

  ref = require('art-standard-lib'), array = ref.array, defineModule = ref.defineModule, log = ref.log, merge = ref.merge, escapeJavascriptString = ref.escapeJavascriptString, find = ref.find;

  Node = require('../Nodes').Node;

  defineModule(module, function() {
    var IndentBlocks;
    return IndentBlocks = (function() {
      var blockLinesRegExp, blockStartRegExp, computeSubsourceToParentSourceMap, matchBlock, matchToEol, matchToEolAndBlock, toEolContent;

      function IndentBlocks() {}

      blockStartRegExp = /\n(?: *\n)*( +)(?=$|[^ \n])/y;

      toEolContent = /(\ *)((?:\ *[^ \n]+)+)\ */y;

      blockLinesRegExp = function(indent) {
        return RegExp("((?:\\s*\\n)(?:" + indent + " *[^\\n ][^\\n]*))+", "y");
      };


      /*
      TODO:
        for matchBlock and matchToEolAndBlock
      
        We also need a source-offset mapper from the new source back to the old-source.
      
        I think the map should just be part of the returned object
       */

      IndentBlocks.matchBlock = matchBlock = function(source, sourceOffset, returnRawMatch) {
        var __, indent, length, linesRegExp, match, rawSubsource, replaceRegExp, replaceWith, subsource, subsourceToParentSourceMap;
        if (returnRawMatch == null) {
          returnRawMatch = false;
        }
        blockStartRegExp.lastIndex = sourceOffset;
        if (match = blockStartRegExp.exec(source)) {
          __ = match[0], indent = match[1];
          length = indent.length;
          linesRegExp = blockLinesRegExp(indent);
          linesRegExp.lastIndex = sourceOffset;
          rawSubsource = linesRegExp.exec(source)[0];
          replaceRegExp = RegExp("(?:^\\n" + indent + ")|(\\n)(?:" + indent + ")", "g");
          replaceWith = "$1";
          subsourceToParentSourceMap = null;
          subsource = returnRawMatch ? rawSubsource : rawSubsource.replace(replaceRegExp, "$1");
          return {
            matchLength: rawSubsource.length,
            subsource: subsource,
            sourceMap: returnRawMatch ? function(suboffset) {
              return suboffset + sourceOffset;
            } : function(suboffset) {
              var bestMapEntry;
              subsourceToParentSourceMap || (subsourceToParentSourceMap = computeSubsourceToParentSourceMap(sourceOffset, replaceRegExp, indent, rawSubsource));
              bestMapEntry = find(subsourceToParentSourceMap, function(entry) {
                if (suboffset < entry.subsourceEndOffset) {
                  return entry;
                }
              });
              if (!bestMapEntry) {
                log({
                  bestMapEntryNotFound: {
                    source: source,
                    rawSubsource: rawSubsource,
                    subsourceToParentSourceMap: subsourceToParentSourceMap,
                    suboffset: suboffset,
                    sourceLength: source.length,
                    rawSubsourceLength: rawSubsource.length,
                    sourceOffset: sourceOffset,
                    indent: indent
                  }
                });
                throw new Error("error getting source location from subparse sourceMap");
              }
              return suboffset + bestMapEntry.toSourceDelta;
            }
          };
        }
      };

      computeSubsourceToParentSourceMap = function(sourceBaseOffset, replaceRegExp, indent, rawSubsource) {
        var indentLength, indentWithNewLineLength, indexes, keptLength, match, matchLength, ref1, removedLength, sourceEndOffset, sourceOffset, subsourceEndOffset, subsourceOffset, toSourceDelta;
        indentLength = indent.length;
        indentWithNewLineLength = indentLength + 1;
        indexes = [];
        sourceOffset = toSourceDelta = sourceBaseOffset;
        subsourceOffset = subsourceEndOffset = 0;
        while (match = replaceRegExp.exec(rawSubsource)) {
          matchLength = match[0].length;
          keptLength = ((ref1 = match[1]) != null ? ref1.length : void 0) || 0;
          removedLength = matchLength - keptLength;
          sourceEndOffset = match.index + sourceBaseOffset + matchLength;
          subsourceEndOffset += sourceEndOffset - sourceOffset - removedLength;
          indexes.push({
            keptLength: keptLength,
            removedLength: removedLength,
            sourceOffset: sourceOffset,
            subsourceOffset: subsourceOffset,
            toSourceDelta: toSourceDelta,
            sourceEndOffset: sourceEndOffset,
            subsourceEndOffset: subsourceEndOffset
          });
          toSourceDelta += removedLength;
          sourceOffset = sourceEndOffset;
          subsourceOffset = subsourceEndOffset;
        }
        sourceEndOffset = sourceBaseOffset + rawSubsource.length;
        subsourceEndOffset = sourceEndOffset - sourceOffset + sourceOffset;
        indexes.push({
          sourceOffset: sourceOffset,
          subsourceOffset: subsourceOffset,
          toSourceDelta: toSourceDelta,
          sourceEndOffset: sourceEndOffset,
          subsourceEndOffset: subsourceEndOffset
        });
        return indexes;
      };

      IndentBlocks.matchToEolAndBlock = matchToEolAndBlock = function(source, offset) {
        var blockMatch, eolMatch, matchLength, sourceMatched, spaces;
        toEolContent.lastIndex = offset;
        if (eolMatch = toEolContent.exec(source)) {
          sourceMatched = eolMatch[0], spaces = eolMatch[1];
          matchLength = sourceMatched.length;
          if (blockMatch = matchBlock(source, offset + matchLength, true)) {
            matchLength += blockMatch.matchLength;
          }
          return {
            subsource: source.slice(offset + spaces.length, offset + matchLength),
            sourceMap: function(suboffset) {
              return offset + spaces.length + suboffset;
            },
            matchLength: matchLength
          };
        } else {
          return matchBlock(source, offset);
        }
      };

      IndentBlocks.matchToEol = matchToEol = function(source, offset) {
        var blockMatch, eolMatch, matchLength, sourceMatched, spaces;
        toEolContent.lastIndex = offset;
        if (eolMatch = toEolContent.exec(source)) {
          sourceMatched = eolMatch[0], spaces = eolMatch[1];
          matchLength = sourceMatched.length;
          if (blockMatch = matchBlock(source, offset + matchLength, true)) {
            matchLength += blockMatch.matchLength;
          }
          return {
            subsource: source.slice(offset + spaces.length, offset + matchLength),
            sourceMap: function(suboffset) {
              return offset + spaces.length + suboffset;
            },
            matchLength: matchLength
          };
        }
      };

      IndentBlocks.getParseFunction = function(matcher, subparseOptions) {
        return {
          parse: subparseOptions.verbose ? function(parentNode) {
            var block, matchLength, offset, parsed, source, sourceMap, subsource;
            offset = parentNode.nextOffset, source = parentNode.source;
            log({
              IndentBlocks_parse_verbose_matcher_attempt: {
                source: source,
                offset: offset
              }
            });
            if (block = matcher(source, offset)) {
              subsource = block.subsource, matchLength = block.matchLength, sourceMap = block.sourceMap;
              log({
                IndentBlocks_parse_verbose_matcher_matched: {
                  subsource: subsource,
                  matchLength: matchLength
                }
              });
              parsed = parentNode.subparse(subsource, merge(subparseOptions, {
                originalOffset: offset,
                originalMatchLength: matchLength,
                sourceMap: sourceMap
              }));
              log({
                IndentBlocks_parse_verbose_matcher_subparse: {
                  subparseOptions: subparseOptions,
                  parsed: parsed
                }
              });
              return parsed;
            }
          } : function(parentNode) {
            var block, matchLength, offset, source, sourceMap, subsource;
            offset = parentNode.nextOffset, source = parentNode.source;
            if (block = matcher(source, offset)) {
              subsource = block.subsource, matchLength = block.matchLength, sourceMap = block.sourceMap;
              return parentNode.subparse(subsource, merge(subparseOptions, {
                originalOffset: offset,
                originalMatchLength: matchLength,
                sourceMap: sourceMap
              }));
            }
          }
        };
      };

      IndentBlocks.getPropsToSubparseToEol = function(subparseOptions) {
        if (subparseOptions == null) {
          subparseOptions = {};
        }
        return IndentBlocks.getParseFunction(IndentBlocks.matchToEol, subparseOptions);
      };

      IndentBlocks.getPropsToSubparseBlock = function(subparseOptions) {
        if (subparseOptions == null) {
          subparseOptions = {};
        }
        return IndentBlocks.getParseFunction(IndentBlocks.matchBlock, subparseOptions);
      };

      IndentBlocks.getPropsToSubparseToEolAndBlock = function(subparseOptions) {
        if (subparseOptions == null) {
          subparseOptions = {};
        }
        return IndentBlocks.getParseFunction(IndentBlocks.matchToEolAndBlock, subparseOptions);
      };

      return IndentBlocks;

    })();
  });

}).call(this);

//# sourceMappingURL=IndentBlocks.js.map
