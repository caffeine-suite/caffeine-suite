"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "log", "Error", "merge"], [global, require('art-standard-lib'), require('art-class-system'), require('../Nodes')], (BaseClass, log, Error, merge) => {let IndentBlocks; return IndentBlocks = Caf.defClass(class IndentBlocks extends BaseClass {}, function(IndentBlocks, classSuper, instanceSuper) {let blockStartRegExp, toEolContent, blockLinesRegExp, matchToEolAndBlock; blockStartRegExp = /\n(?: *\n)*( +)(?=$|[^ \n])/y; toEolContent = /(\ *)((?:\ *[^ \n]+)+)\ */y; blockLinesRegExp = function(indent) {return RegExp(`((?:\\s*\\n)(?:${Caf.toString(indent)} *[^\\n ][^\\n]*))+`, 'y');}; this.matchBlock = (source, sourceOffset, returnRawMatch = false) => {let match, indent, length, linesRegExp, rawSubsource, replaceRegExp, subsourceToParentSourceMap; blockStartRegExp.lastIndex = sourceOffset; return (match = blockStartRegExp.exec(source)) ? (indent = match[1], length = indent.length, linesRegExp = blockLinesRegExp(indent), linesRegExp.lastIndex = sourceOffset, ([rawSubsource] = linesRegExp.exec(source)), replaceRegExp = RegExp(`(?:^\\n${Caf.toString(indent)})|(\\n)(?:${Caf.toString(indent)})`, 'g'), subsourceToParentSourceMap = null, {subsource: returnRawMatch ? rawSubsource : rawSubsource.replace(replaceRegExp, "$1"), matchLength: rawSubsource.length, sourceMap: returnRawMatch ? (suboffset) => suboffset + sourceOffset : (suboffset) => {let bestMapEntry; subsourceToParentSourceMap || (subsourceToParentSourceMap = this._computeSubsourceToParentSourceMap(sourceOffset, replaceRegExp, indent, rawSubsource)); bestMapEntry = Caf.find(subsourceToParentSourceMap, null, (entry) => suboffset < entry.subsourceEndOffset); if (!bestMapEntry) {log({bestMapEntryNotFound: {source, rawSubsource, subsourceToParentSourceMap, suboffset, sourceLength: source.length, rawSubsourceLength: rawSubsource.length, sourceOffset, indent}}); throw new Error("error getting source location from subparse sourceMap");}; return suboffset + bestMapEntry.toSourceDelta;}}) : undefined;}; this._computeSubsourceToParentSourceMap = (sourceBaseOffset, replaceRegExp, indent, rawSubsource) => {let indentLength, indentWithNewLineLength, indexes, sourceOffset, toSourceDelta, subsourceOffset, subsourceEndOffset, match, sourceEndOffset; indentLength = indent.length; indentWithNewLineLength = indentLength + 1; indexes = []; sourceOffset = toSourceDelta = sourceBaseOffset; subsourceOffset = subsourceEndOffset = 0; match = null; while (match = replaceRegExp.exec(rawSubsource)) {let matchLength, keptLength, removedLength, base; matchLength = match[0].length; keptLength = Caf.exists(base = match[1]) && base.length || 0; removedLength = matchLength - keptLength; sourceEndOffset = match.index + sourceBaseOffset + matchLength; subsourceEndOffset += sourceEndOffset - sourceOffset - removedLength; indexes.push({keptLength, removedLength, sourceOffset, subsourceOffset, toSourceDelta, sourceEndOffset, subsourceEndOffset}); toSourceDelta += removedLength; sourceOffset = sourceEndOffset; subsourceOffset = subsourceEndOffset;}; sourceEndOffset = sourceBaseOffset + rawSubsource.length; subsourceEndOffset = sourceEndOffset - sourceOffset + sourceOffset; indexes.push({sourceOffset, subsourceOffset, toSourceDelta, sourceEndOffset, subsourceEndOffset}); return indexes;}; this.matchToEolAndBlock = matchToEolAndBlock = (source, offset) => {let eolMatch, sourceMatched, spaces, matchLength, blockMatch; toEolContent.lastIndex = offset; return (eolMatch = toEolContent.exec(source)) ? (([sourceMatched, spaces] = eolMatch), matchLength = sourceMatched.length, (blockMatch = this.matchBlock(source, offset + matchLength, true)) ? matchLength += blockMatch.matchLength : undefined, {subsource: source.slice(offset + spaces.length, offset + matchLength), sourceMap: (suboffset) => offset + spaces.length + suboffset, matchLength}) : this.matchBlock(source, offset);}; this.matchToEol = (source, offset) => {let eolMatch, sourceMatched, spaces, matchLength, blockMatch; toEolContent.lastIndex = offset; return (eolMatch = toEolContent.exec(source)) ? (([sourceMatched, spaces] = eolMatch), matchLength = sourceMatched.length, (blockMatch = this.matchBlock(source, offset + matchLength, true)) ? matchLength += blockMatch.matchLength : undefined, {subsource: source.slice(offset + spaces.length, offset + matchLength), sourceMap: (suboffset) => offset + spaces.length + suboffset, matchLength}) : undefined;}; this.getParseFunction = (matcher, subparseOptions) => {return {parse: subparseOptions.verbose ? (parentNode) => {let offset, source, block, subsource, matchLength, sourceMap, parsed; ({nextOffset: offset, source} = parentNode); log({IndentBlocks_parse_verbose_matcher_attempt: {source, offset}}); return (block = matcher(source, offset)) ? (({subsource, matchLength, sourceMap} = block), log({IndentBlocks_parse_verbose_matcher_matched: {subsource, matchLength}}), parsed = parentNode.subparse(subsource, merge(subparseOptions, {originalOffset: offset, originalMatchLength: matchLength, sourceMap})), log({IndentBlocks_parse_verbose_matcher_subparse: {subparseOptions, parsed}}), parsed) : undefined;} : (parentNode) => {let offset, source, block, subsource, matchLength, sourceMap; ({nextOffset: offset, source} = parentNode); return (block = matcher(source, offset)) ? (({subsource, matchLength, sourceMap} = block), parentNode.subparse(subsource, merge(subparseOptions, {originalOffset: offset, originalMatchLength: matchLength, sourceMap}))) : undefined;}};}; this.getPropsToSubparseToEol = (subparseOptions = {}) => this.getParseFunction(this.matchToEol, subparseOptions); this.getPropsToSubparseBlock = (subparseOptions = {}) => this.getParseFunction(this.matchBlock, subparseOptions); this.getPropsToSubparseToEolAndBlock = (subparseOptions = {}) => this.getParseFunction(this.matchToEolAndBlock, subparseOptions);});});});
//# sourceMappingURL=IndentBlocks.js.map
