"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isPlainArray", "isPlainObject", "peek", "arrayWithoutLast", "compactFlatten", "merge", "Error", "Rule", "log", "isClass"], [global, require('art-standard-lib'), {Rule: require('./Rule')}], (isPlainArray, isPlainObject, peek, arrayWithoutLast, compactFlatten, merge, Error, Rule, log, isClass) => {let normalizeVariantDefinitions, Parser; normalizeVariantDefinitions = function(variantDefinitions, nodeBaseClass) {let last, commonNodeProps, out, temp; if (!isPlainArray(variantDefinitions)) {variantDefinitions = [variantDefinitions];}; if (variantDefinitions.length > 1 && (isPlainObject(last = peek(variantDefinitions)) && !(((temp = last.pattern) != null ? temp : last.parse)))) {commonNodeProps = peek(variantDefinitions); variantDefinitions = arrayWithoutLast(variantDefinitions);} else {commonNodeProps = {};}; commonNodeProps.nodeBaseClass || (commonNodeProps.nodeBaseClass = nodeBaseClass); out = []; Caf.each2(compactFlatten(variantDefinitions), (definition) => {let patterns; if (!isPlainObject(definition)) {definition = {pattern: definition};}; return isPlainArray(patterns = definition.pattern) ? Caf.each2(patterns, (pattern) => out.push(merge(commonNodeProps, definition, {pattern}))) : out.push(merge(commonNodeProps, definition));}); return out;}; return Parser = Caf.defClass(class Parser extends require('./ParserCoffee') {}, function(Parser, classSuper, instanceSuper) {let rulesFunction, instanceRulesFunction; this.classGetter({rootRuleName: function() {return this._rootRuleName || "root";}, rootRule: function() {return this.getRules()[this._rootRuleName];}}); this.extendableProperty({rules: {}}, {noSetter: true, extend: function(extendableRules, newRules) {return Caf.object(newRules, (newRule) => newRule.clone(), null, extendableRules);}}); this.rule = rulesFunction = function(...args) {return Caf.each2(this._normalizeRuleDefinition(...args), (definition, ruleName) => this._addRule(ruleName, definition));}; this.rules = rulesFunction; this.replaceRule = function(...args) {return Caf.each2(this._normalizeRuleDefinition(...args), (definition, ruleName) => this._replaceRule(this._newRule(ruleName), ruleName, definition, true));}; this.priorityRule = function(...args) {return Caf.each2(this._normalizeRuleDefinition(...args), (definition, ruleName) => this._addRule(ruleName, definition, true));}; this.prototype.rule = instanceRulesFunction = function() {return (() => {throw new Error("DEPRICATED: instance.rule(s) is not suppoerted; use class.rule(s) instead");})();}; this._extendRule = function(ruleName) {let rule; return (rule = this.extendRules()[ruleName]) ? (rule.definedInClass !== this) ? rule.clone() : rule : this._newRule(ruleName);}; this._newRule = function(ruleName) {return new Rule(ruleName, this);}; this._addRule = function(ruleName, variantDefinitions, addPriorityVariants) {if (variantDefinitions.root) {if (this._rootRuleName) {throw new Error(`root rule already defined! was: ${Caf.toString(this._rootRuleName)}, wanted: ${Caf.toString(ruleName)}`);}; if (!(ruleName === "root")) {log.warn("DEPRICATED: root rule should always be called 'root' now");}; this._rootRuleName = ruleName;}; return this._replaceRule(this._extendRule(ruleName), ruleName, variantDefinitions, addPriorityVariants);}; this._replaceRule = function(rule, ruleName, variantDefinitions, addPriorityVariants) {this.extendRules()[ruleName] = rule; return Caf.each2(variantDefinitions, (definition) => rule.addVariant(definition, addPriorityVariants));}; this._normalizeRuleDefinition = function(a, b) {let nodeBaseClass, _rules; if (isClass(a)) {nodeBaseClass = a; _rules = b;} else {_rules = a; nodeBaseClass = b;}; if (isPlainObject(nodeBaseClass)) {nodeBaseClass = this.getNodeBaseClass().createSubclass(nodeBaseClass);} else {nodeBaseClass != null ? nodeBaseClass : nodeBaseClass = this.getNodeBaseClass();}; return Caf.object(_rules, (definition, ruleName) => normalizeVariantDefinitions(definition, nodeBaseClass));};});});});
//# sourceMappingURL=Parser.js.map
