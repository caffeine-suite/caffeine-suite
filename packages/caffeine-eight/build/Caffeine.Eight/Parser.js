"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "isPlainArray", "isPlainObject", "peek", "arrayWithoutLast", "compactFlatten", "merge", "ScratchNode", "Stats", "Error", "max", "Node", "objectLength", "objectHasKeys", "pushIfNotPresent", "presentSourceLocation", "formattedInspect", "CaffeineEightCompileError", "SourceLineColumnMap", "pluralize", "Rule", "log", "isClass", "NonMatch"], [global, require('art-standard-lib'), require('art-class-system'), require('./Nodes'), require('./Lib'), {Rule: require('./Rule'), NonMatch: require('./NonMatch'), Stats: require('./Stats'), SourceLineColumnMap: require('./SourceLineColumnMap'), CaffeineEightCompileError: require('./CaffeineEightCompileError')}], (BaseClass, isPlainArray, isPlainObject, peek, arrayWithoutLast, compactFlatten, merge, ScratchNode, Stats, Error, max, Node, objectLength, objectHasKeys, pushIfNotPresent, presentSourceLocation, formattedInspect, CaffeineEightCompileError, SourceLineColumnMap, pluralize, Rule, log, isClass, NonMatch) => {let normalizeVariantDefinitions, Parser; normalizeVariantDefinitions = function(variantDefinitions, nodeBaseClass) {let last, commonNodeProps, out, temp; if (!isPlainArray(variantDefinitions)) {variantDefinitions = [variantDefinitions];}; if (variantDefinitions.length > 1 && (isPlainObject(last = peek(variantDefinitions)) && !(((temp = last.pattern) != null ? temp : last.parse)))) {commonNodeProps = peek(variantDefinitions); variantDefinitions = arrayWithoutLast(variantDefinitions);} else {commonNodeProps = {};}; commonNodeProps.nodeBaseClass || (commonNodeProps.nodeBaseClass = nodeBaseClass); out = []; Caf.each2(compactFlatten(variantDefinitions), (definition) => {let patterns; if (!isPlainObject(definition)) {definition = {pattern: definition};}; return isPlainArray(patterns = definition.pattern) ? Caf.each2(patterns, (pattern) => out.push(merge(commonNodeProps, definition, {pattern}))) : out.push(merge(commonNodeProps, definition));}); return out;}; return Parser = Caf.defClass(class Parser extends BaseClass {constructor() {super(...arguments); this._options = null; this._parser = this; this._source = null; this._resetParserTracking();};}, function(Parser, classSuper, instanceSuper) {let rulesFunction, instanceRulesFunction; this.repl = function(options) {return require('./Repl').caffeineEightRepl(this, options);}; this.parse = function(_source, options = {}) {this._source = _source; return (new this).parse(this._source, options);}; this.property("subparseInfo", "options"); this.getter("source", "parser", {rootRuleName: function() {return this.class.getRootRuleName();}, rootRule: function() {return this.class.getRootRule();}, nextOffset: function() {return 0;}, rootParser: function() {let base; return Caf.exists(base = this.parentParser) && base.rootParser || this;}, rootSource: function() {return this.rootParser.source;}, ancestors: function(_into) {_into.push(this); return _into;}, parseInfo: function() {return "Parser";}, failureIndexInParentParser: function() {return this.offsetInParentParserSource(this._failureIndex);}}); this.prototype.parse = function(_source, options = {}) {let allowPartialMatch, rule, isSubparse, logParsingFailures, startRule, rootParseTreeNode; this._source = _source; this.options = options; ({allowPartialMatch, rule, isSubparse, logParsingFailures} = this.options); this.parentParser = options.parentParser; startRule = this.getRule(rule); this._resetParserTracking(); this._logParsingFailures = logParsingFailures; return (() => {try {return ((rootParseTreeNode = startRule.parse(this)) && (rootParseTreeNode.matchLength === this._source.length || allowPartialMatch && rootParseTreeNode.matchLength > 0)) ? (!isSubparse ? rootParseTreeNode.applyLabels() : undefined, rootParseTreeNode) : !isSubparse ? logParsingFailures ? (() => {throw this.generateCompileError(merge(this.options, {rootParseTreeNode}));})() : this.parse(this._source, merge(this.options, {logParsingFailures: true})) : undefined;} finally {if (!isSubparse) {ScratchNode.resetAll();};};})();}; this.prototype.subparse = function(subsource, options = {}) {let subparser, originalMatchLength, parentNode, sourceMap, originalOffset, match, offset, matchLength, source, parser, failureIndex, from, into, temp; Stats.add("subparse"); subparser = new this.class; originalMatchLength = options.originalMatchLength; parentNode = options.parentNode; sourceMap = options.sourceMap; originalOffset = options.originalOffset; options.parentParser = this; options.sourceFile = this.options.sourceFile; return (match = subparser.parse(subsource, merge(options, {isSubparse: true, logParsingFailures: this._logParsingFailures}))) ? ((offset = match.offset, matchLength = match.matchLength, source = match.source, parser = match.parser), match.subparseInfo = {offset, matchLength, source, parser}, (match.matchLength < subsource.length) ? originalMatchLength = sourceMap ? sourceMap(match.matchLength) - parentNode.nextOffset : (match.text === parentNode.getNextText(match.matchLength)) ? match.matchLength : (() => {throw new Error("Subparse requires a sourceMap to determine the match-length in the parent text for partial-matches.");})() : undefined, match.offset = parentNode.nextOffset, match.matchLength = originalMatchLength, match._parser = parentNode._parser, match._parent = parentNode, match) : (failureIndex = subparser.failureIndexInParentParser, (from = subparser._nonMatches, into = from, (from != null) ? (() => {for (let k1 in from) {let nonMatch, k, rootNode; nonMatch = from[k1]; k = k1; temp = (rootNode = nonMatch.node, (() => {while (rootNode !== parentNode && rootNode.parent instanceof Node) {rootNode = rootNode.parent;};})(), (rootNode !== parentNode) ? rootNode._parent = parentNode : undefined, this._logParsingFailures ? this._addNonMatch(failureIndex, nonMatch) : this._failureIndex = max(this._failureIndex, failureIndex));}; return temp;})() : undefined, into), null);}; this.getter("nonMatches", {sourceFile: function() {return this.options.sourceFile;}, failureUrl: function(failureIndex = this._failureIndex) {return `${Caf.toString(this.options.sourceFile || "")}:${Caf.toString(this.getLineColumnString(failureIndex))}`;}, parseFailureInfoObject: function(options) {let failureIndex, temp; failureIndex = ((temp = Caf.exists(options) && options.failureIndex) != null ? temp : this._failureIndex); return this.parentParser ? this.rootParser.getParseFailureInfoObject({failureIndex: this.offsetInRootParserSource(failureIndex)}) : merge({sourceFile: this.options.sourceFile, failureIndex, location: this.getFailureUrl(failureIndex), expectingInfo: (failureIndex === this._failureIndex) ? this.expectingInfo : undefined}, this.getLineColumn(failureIndex));}, partialParseTree: function() {let rootNode; if (this._partialParseTree) {return this._partialParseTree;}; rootNode = undefined; this._partialParseTreeNodes = Caf.array(this._nonMatches, ({patternElement, node}) => {let n; n = new Node(node); n.pattern = patternElement; rootNode = n._addToParentAsNonMatch(); return n;}); return this._partialParseTree = rootNode;}, expectingInfo: function() {let partialMatchingParents, couldMatchRuleNames, expecting, out; if (!(objectLength(this._nonMatches) > 0)) {return null;}; if (this._expectingInfo) {return this._expectingInfo;}; partialMatchingParents = []; Caf.each2(this.partialParseTreeLeafNodes, (node) => {let firstPartialMatchParent; ({firstPartialMatchParent} = node); return pushIfNotPresent(partialMatchingParents, firstPartialMatchParent);}); couldMatchRuleNames = []; expecting = {}; Caf.each2(partialMatchingParents, (pmp) => Caf.each2(pmp.matches, (child) => {let ruleName; if (ruleName = child.nonMatchingLeaf.ruleNameOrNull) {couldMatchRuleNames.push(ruleName);}; return expecting[child.nonMatchingLeaf.ruleNameOrPattern] = {"to-continue": pmp.ruleName, "started-at": this.getLineColumnString(pmp.absoluteOffset)};}, (child) => child.isNonMatch && child.nonMatchingLeaf)); return this._expectingInfo = objectHasKeys(expecting) ? (out = {expecting}, (couldMatchRuleNames.length > 1) ? (out.rules = {}, Caf.each2(couldMatchRuleNames, (ruleName) => Caf.each2(this.rules[ruleName]._variants, (v) => out.rules[ruleName] = v.patternString))) : undefined, out) : {expecting: "end of input"};}, parseFailureInfo: function(options = {}) {let error, failureOffset, failureIndex, verbose, errorType; if (!this._source) {return;}; ({error, failureOffset, failureIndex = this._failureIndex, verbose, errorType = "Parsing"} = options); if (failureOffset != null) {throw new Error("DEPRICATED: failureOffset");}; return this.parentParser ? this.rootParser.getParseFailureInfo({failureIndex: this.offsetInRootParserSource(failureIndex), verbose, errorType}) : compactFlatten([this.colorString("gray", `${Caf.toString(errorType)} error at ${Caf.toString(this.colorString("red", this.getFailureUrl(failureIndex)))}`), "", this.colorString("gray", "Source:"), this.colorString("gray", "..."), presentSourceLocation(this._source, failureIndex, this.options), this.colorString("gray", "..."), "", this.expectingInfo ? formattedInspect(this.expectingInfo, options) : error, verbose ? formattedInspect({"partial-parse-tree": this.partialParseTree}, options) : undefined, ""]).join("\n");}, partialParseTreeLeafNodes: function() {if (this._partialParseTreeNodes) {return this._partialParseTreeNodes;}; this.getPartialParseTree(); return this._partialParseTreeNodes;}}); this.prototype.generateCompileError = function(options) {let message, info, rootParseTreeNode; ({message, info, rootParseTreeNode} = options); return new CaffeineEightCompileError(compactFlatten([((Caf.exists(rootParseTreeNode) && rootParseTreeNode.matchLength) < this._source.length) ? this.colorString("gray", `${Caf.toString(this.class.name)} only parsed: `) + this.colorString("black", `${Caf.toString(rootParseTreeNode.matchLength)} of ${Caf.toString(this._source.length)} `) + this.colorString("gray", "characters") : undefined, this.getParseFailureInfo(options), message]).join("\n"), merge(this.getParseFailureInfoObject(options), info));}; this.getNodeBaseClass = function() {let temp, temp1; return ((temp = this._nodeBaseClass) != null ? temp : this._nodeBaseClass = isPlainObject(this.nodeBaseClass) ? Node.createSubclass(merge({name: this.getName() + "NodeBaseClass"}, this.nodeBaseClass)) : ((temp1 = this.nodeBaseClass) != null ? temp1 : Node));}; this.prototype.getRule = function(ruleName) {let temp; ruleName != null ? ruleName : ruleName = this.rootRuleName; if (!ruleName) {throw new Error("No root rule defined.");}; return ((temp = this.rules[ruleName]) != null ? temp : (() => {throw new Error(`Could not find rule: ${Caf.toString(ruleName)}`);})());}; this.prototype.colorString = function(clr, str) {return this.options.color ? `${Caf.toString(str)}`[clr] : str;}; this.prototype.offsetInParentParserSource = function(suboffset) {let sourceMap, originalOffset; ({sourceMap, originalOffset = 0} = this.options); return sourceMap ? (!(suboffset <= this.source.length) ? (() => {throw new Error(`suboffset (${Caf.toString(suboffset)}) > source.length (${Caf.toString(this.source.length)})`);})() : undefined, sourceMap(suboffset)) : this.parentParser ? this.options.originalOffset + suboffset : suboffset;}; this.prototype.offsetInRootParserSource = function(suboffset) {return this.parentParser ? this.parentParser.offsetInRootParserSource(this.offsetInParentParserSource(suboffset)) : suboffset;}; this.prototype.getLineColumn = function(offset, _into) {let temp; return (((temp = this._sourceLineColumnMap) != null ? temp : this._sourceLineColumnMap = new SourceLineColumnMap(this._source))).getLineColumn(offset, _into);}; this.prototype.getLineColumnString = function(offset, _into) {let line, column, a; ({line, column} = a = this.getLineColumn(offset, _into)); return `${Caf.toString(line + 1)}:${Caf.toString(column + 1)}`;}; this.prototype.tryPatternElement = function(patternElement, parseIntoNode, ruleVariant) {Stats.add("tryPatternElement"); return patternElement.parseInto(parseIntoNode) ? true : (this._logParsingFailure(parseIntoNode, patternElement), false);}; this._pluralNames = {}; this.pluralize = function(name) {let pluralName; if (!(pluralName = this._pluralNames[name])) {pluralName = pluralize(name); if (pluralName === name) {pluralName += "s";}; this._pluralNames[name] = pluralName;}; return pluralName;}; this.prototype.pluralize = function(name) {return this.class.pluralize(name);}; this.classGetter({rootRuleName: function() {return this._rootRuleName || "root";}, rootRule: function() {return this.getRules()[this._rootRuleName];}}); this.extendableProperty({rules: {}}, {noSetter: true, extend: function(extendableRules, newRules) {return Caf.object(newRules, (newRule) => newRule.clone(), null, extendableRules);}}); this.rule = rulesFunction = function(...args) {return Caf.each2(this._normalizeRuleDefinition(...args), (definition, ruleName) => this._addRule(ruleName, definition));}; this.rules = rulesFunction; this.replaceRule = function(...args) {return Caf.each2(this._normalizeRuleDefinition(...args), (definition, ruleName) => this._replaceRule(this._newRule(ruleName), ruleName, definition, true));}; this.priorityRule = function(...args) {return Caf.each2(this._normalizeRuleDefinition(...args), (definition, ruleName) => this._addRule(ruleName, definition, true));}; this.prototype.rule = instanceRulesFunction = function() {return (() => {throw new Error("DEPRICATED: instance.rule(s) is not suppoerted; use class.rule(s) instead");})();}; this._extendRule = function(ruleName) {let rule; return (rule = this.extendRules()[ruleName]) ? (rule.definedInClass !== this) ? rule.clone() : rule : this._newRule(ruleName);}; this._newRule = function(ruleName) {return new Rule(ruleName, this);}; this._addRule = function(ruleName, variantDefinitions, addPriorityVariants) {if (variantDefinitions.root) {if (this._rootRuleName) {throw new Error(`root rule already defined! was: ${Caf.toString(this._rootRuleName)}, wanted: ${Caf.toString(ruleName)}`);}; if (!(ruleName === "root")) {log.warn("DEPRICATED: root rule should always be called 'root' now");}; this._rootRuleName = ruleName;}; return this._replaceRule(this._extendRule(ruleName), ruleName, variantDefinitions, addPriorityVariants);}; this._replaceRule = function(rule, ruleName, variantDefinitions, addPriorityVariants) {this.extendRules()[ruleName] = rule; return Caf.each2(variantDefinitions, (definition) => rule.addVariant(definition, addPriorityVariants));}; this._normalizeRuleDefinition = function(a, b) {let nodeBaseClass, _rules; if (isClass(a)) {nodeBaseClass = a; _rules = b;} else {_rules = a; nodeBaseClass = b;}; if (isPlainObject(nodeBaseClass)) {nodeBaseClass = this.getNodeBaseClass().createSubclass(nodeBaseClass);} else {nodeBaseClass != null ? nodeBaseClass : nodeBaseClass = this.getNodeBaseClass();}; return Caf.object(_rules, (definition, ruleName) => normalizeVariantDefinitions(definition, nodeBaseClass));}; this.prototype._getRuleParseCache = function(ruleName) {let temp, base; return ((temp = (base = this._parseCache)[ruleName]) != null ? temp : base[ruleName] = {});}; this.prototype._cached = function(ruleName, offset) {return this._getRuleParseCache(ruleName)[offset];}; this.prototype._cacheMatch = function(ruleName, matchingNode) {Stats.add("cacheMatch"); this._getRuleParseCache(ruleName)[matchingNode.offset] = matchingNode; return matchingNode;}; this.prototype._cacheNoMatch = function(ruleName, offset) {Stats.add("cacheNoMatch"); this._getRuleParseCache(ruleName)[offset] = "no_match"; return null;}; this.prototype._resetParserTracking = function() {this._activeRuleVariantParserOffsets = {}; this._subparseInfo = null; this._logParsingFailures = false; this._partialParseTreeNodes = null; this._partialParseTree = null; this._matchingNegativeDepth = 0; this._parsingDidNotMatchEntireInput = false; this._failureIndex = 0; this._expectingInfo = null; this._nonMatches = {}; this._parseCache = {}; return this._parentParserRootOffset = null;}; this.getter("activeRuleVariantParserOffsets", "activeRuleVariantParserAreLeftRecursive", "failureIndex", {isMatchingNegative: function() {return this._matchingNegativeDepth > 0;}}); this.prototype._matchNegative = function(f) {let result; this._matchingNegativeDepth++; result = f(); this._matchingNegativeDepth--; return result;}; this.prototype._logParsingFailure = function(parseIntoNode, patternElement) {let nextOffset; ({nextOffset} = parseIntoNode); return (this._matchingNegativeDepth === 0 && nextOffset >= this._failureIndex && patternElement.isTokenPattern) ? this._logParsingFailures ? (parseIntoNode = parseIntoNode.getRealNode(), this._addNonMatch(nextOffset, new NonMatch(parseIntoNode, patternElement))) : this._failureIndex = nextOffset : undefined;}; this.prototype._addNonMatch = function(offset, nonMatch) {if (offset > this._failureIndex) {this._failureIndex = offset; this._nonMatches = {};}; return this._nonMatches[nonMatch] = nonMatch;};});});});
//# sourceMappingURL=Parser.js.map
