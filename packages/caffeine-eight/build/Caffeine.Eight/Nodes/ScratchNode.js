"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "Error", "toInspectedObjects", "merge"], [global, require('art-standard-lib'), require('art-class-system')], (BaseClass, Error, toInspectedObjects, merge) => {let ScratchNode; return ScratchNode = Caf.defClass(class ScratchNode extends BaseClass {constructor(parent, ruleVariant) {super(...arguments); this.matches = []; this.matchPatterns = []; this.reset(parent, ruleVariant);};}, function(ScratchNode, classSuper, instanceSuper) {this.resetAll = function() {this._scatchNodes = []; return this._scatchNodesInUse = 0;}; this.resetAll(); this.checkout = function(parentNode, ruleVariant) {return (this._scatchNodesInUse >= this._scatchNodes.length) ? this._scatchNodes[this._scatchNodesInUse++] = new ScratchNode(parentNode, ruleVariant) : this._scatchNodes[this._scatchNodesInUse++].reset(parentNode, ruleVariant);}; this.checkin = function(scratchNode) {return !(scratchNode === this._scatchNodes[--this._scatchNodesInUse]) ? (() => {throw new Error("unknown error");})() : undefined;}; this.prototype.reset = function(parent, ruleVariant) {this.parent = parent; this.ruleVariant = ruleVariant; this._parser = this.parent._parser; this.offset = this.parent.getNextOffset() | 0; this.matchesLength = this.matchPatternsLength = this.matchLength = 0; this.variantNode = null; return this;}; this.getter("parser", {source: function() {return this._parser.source;}, nextOffset: function() {return this.offset + this.matchLength;}, inspectedObjects: function() {return {offset: this.offset, matchLength: this.matchLength, matches: toInspectedObjects(this.matches), matchPatterns: toInspectedObjects(this.matchPatterns)};}}); this.prototype.getNextText = function(length) {let nextOffset; nextOffset = this.getNextOffset(); return this.source.slice(nextOffset, nextOffset + length);}; this.getter({firstPartialMatchParent: function() {return this.realNode.firstPartialMatchParent;}, realNode: function() {let temp; return ((temp = this.variantNode) != null ? temp : this.variantNode = new (this.ruleVariant.VariantNodeClass)(this.parent.realNode || this._parser, {ruleVariant: this.ruleVariant, matchLength: this.matchLength, matches: this.matchesLength > 0 && this.matches.slice(0, this.matchesLength), matchPatterns: this.matchPatternsLength > 0 && this.matchPatterns.slice(0, this.matchPatternsLength)}));}}); this.prototype.checkin = function() {return ScratchNode.checkin(this);}; this.prototype.subparse = function(subSource, options) {return this._parser.subparse(subSource, merge(options, {parentNode: this}));}; this.prototype.addMatch = function(pattern, match) {let base; if (!match) {return false;}; Caf.exists(base = this.variantNode) && base.addMatch(pattern, match); this.matches[this.matchesLength++] = match; this.matchPatterns[this.matchPatternsLength++] = pattern; this.matchLength = match.nextOffset - this.offset; return true;}; this.prototype._addToParentAsNonMatch = function() {return this.realNode._addToParentAsNonMatch();};});});});
//# sourceMappingURL=ScratchNode.js.map
