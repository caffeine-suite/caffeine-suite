"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "mergeInto", "objectWithout", "compactFlatten", "peek", "merge", "push", "Nodes", "Stats", "Error"], [global, require('art-standard-lib'), require('art-class-system'), {Nodes: require('./'), Stats: require('../Stats')}], (BaseClass, mergeInto, objectWithout, compactFlatten, peek, merge, push, Nodes, Stats, Error) => {let Node; return Node = Caf.defClass(class Node extends BaseClass {constructor(parent, options) {let temp; super(...arguments); Stats.add("newNode"); this._parent = parent; this._parser = parent._parser; this._absoluteOffset = -1; this._offset = (((temp = Caf.exists(options) && options.offset) != null ? temp : this._parent.getNextOffset())) | 0; if (this._offset > this._parser.source.length) {throw new Error(`bad offset ${Caf.toString(this.inspectedName)} - offset:${Caf.toString(this._offset)} > sourceLength:${Caf.toString(this._parser.source.length)}`);}; this._matchLength = 0; this._ruleName = this._pluralRuleName = this._label = this._pluralLabel = this._pattern = this._nonMatches = this._ruleVariant = this._matches = this._matchPatterns = null; this._labelsApplied = this._nonMatch = false; if (options) {this._matchLength = (options.matchLength || 0) | 0; this._ruleVariant = options.ruleVariant; this._matches = options.matches; this._matchPatterns = options.matchPatterns;};};}, function(Node, classSuper, instanceSuper) {let emptyArray; this._createSubclassBase = function() {let NodeSubclass; return NodeSubclass = Caf.defClass(class NodeSubclass extends this {});}; this.createSubclass = function(options) {let klass; klass = this._createSubclassBase(); if (options.name) {klass._name = klass.prototype._name = options.name;}; if (options.ruleVariant) {klass.ruleVariant = options.ruleVariant; klass.rule = klass.ruleVariant.rule;}; mergeInto(klass.prototype, objectWithout(options, "getter")); if (options.getter) {klass.getter(options.getter);}; return klass;}; this.prototype.toString = function() {return this.text;}; this.prototype.getSourceLineColumn = function(_into) {return this.parser.getLineColumn(this.offset, _into);}; emptyArray = []; this.setter("matches offset matchLength ruleVariant pattern matchPatterns"); this.getter("parent parser offset matchLength matchPatterns label pluralLabel ruleName pluralRuleName pattern nonMatch", {realNode: function() {return this;}, name: function() {return this._name || this.ruleName || this.class.getName();}, present: function() {return this._matchLength > 0 || this._nonMatch;}, matches: function() {return this._matches || (this._matches = []);}, source: function() {return this._parser.source;}, isRoot: function() {return this._parser === this._parent;}, hasMatches: function() {let base; return (Caf.exists(base = this._matches) && base.length) > 0;}, absoluteOffset: function() {return (this._absoluteOffset >= 0) ? this._absoluteOffset : this._absoluteOffset = this._parser.offsetInRootParserSource(this._offset);}, ancestors: function(_into = []) {this.parent.getAncestors(_into); _into.push(this); return _into;}, sourceFile: function() {return this._parser.sourceFile;}, parseInfo: function() {return this.subparseInfo ? `subparse:${Caf.toString(this.ruleName)}:${Caf.toString(this.offset)}` : `${Caf.toString(this.ruleName)}:${Caf.toString(this.offset)}`;}, rulePath: function() {let ancestorRuleNames; ancestorRuleNames = Caf.array(this.ancestors, (ancestor) => ancestor.parseInfo); return ancestorRuleNames.join(" > ");}, nextOffset: function() {return this.offset + this.matchLength;}, text: function() {let matchLength, offset, source; ({matchLength, offset, source} = this.subparseInfo || this); return (matchLength === 0) ? "" : source.slice(offset, offset + matchLength);}, ruleVariant: function() {let base; return this._ruleVariant || Caf.exists(base = this._parent) && base.ruleVariant;}, ruleName: function() {let base; return this.ruleNameOrNull || Caf.exists(base = this.parent) && base.ruleName || `${Caf.toString(this.pattern || "no rule")}`;}, ruleNameOrNull: function() {let base, base1; return Caf.exists(base = this.class.rule) && base.getName() || Caf.exists(base1 = this._ruleVariant) && base1.rule.getName();}, ruleNameOrPattern: function() {let base; return this.ruleNameOrNull || `${Caf.toString(Caf.exists(base = this.pattern) && base.pattern || "no rule")}`;}, isRuleNode: function() {return this.class.rule;}, isPassThrough: function() {let base; return Caf.exists(base = this.ruleVariant) && base.isPassThrough;}, nonPassThrough: function() {let base; return !(Caf.exists(base = this.ruleVariant) && base.isPassThrough);}}); this.prototype.getNextText = function(length) {let nextOffset; ({nextOffset} = this); return this.source.slice(nextOffset, nextOffset + length);}; this.prototype.formattedInspect = function() {return "CUSTOM";}; this.getter({parseTreePath: function() {let base; return compactFlatten([Caf.exists(base = this.parent) && base.parseTreePath, this.class.getName()]);}, presentMatches: function() {return Caf.array(this.matches, null, (m) => Caf.isF(m.getPresent) && m.getPresent());}, isNonMatch: function() {return !!this.nonMatch;}, isPartialMatch: function() {if (!this.nonMatch) {return false;}; return !!Caf.find(this.presentMatches, null, (match) => !match.nonMatch);}, isMatch: function() {return !this.nonMatch;}, nonMatchingLeaf: function() {return this.nonMatch && peek(this.matches) || this;}, firstPartialMatchParent: function() {return (this.parent === this.parser || this.isPartialMatch) ? this : this.parent.firstPartialMatchParent;}, inspectedName: function() {let l; return `${Caf.toString((l = this.label) ? `${Caf.toString(l)}:` : "")}${Caf.toString(this.ruleName)}`;}, children: function() {return Caf.array(this.presentMatches, null, (match) => Caf.isF(match.getPresent) && match.getPresent() && !match.nonMatch);}, inspectedObjects: function(verbose) {let match, matches, path, label, ruleName, nonMatch, hasOneOrMoreMatchingChildren, children, parts, p, temp, base, base1, base2; match = this; matches = this.presentMatches; return (matches.length > 0) ? (path = [], (() => {while (matches.length === 1 && matches[0].matches && matches[0].matches.length > 0) {path.push(match.inspectedName); ([match] = matches); matches = match.presentMatches;};})(), (label = match.label, ruleName = match.ruleName, nonMatch = match.nonMatch), path.push(ruleName), path = path.join("."), hasOneOrMoreMatchingChildren = false, children = Caf.array(matches, (match) => {if (!match.nonMatch) {hasOneOrMoreMatchingChildren = true;}; return match.getInspectedObjects(verbose);}), parts = compactFlatten([label ? {label} : undefined, (this.absoluteOffset !== this.offset) ? {offset: this.offset, absoluteOffset: this.absoluteOffset} : {offset: this.offset}, (children.length > 0) ? children : match.toString()]), (parts.length === 1) ? parts = parts[0] : undefined, p = nonMatch ? hasOneOrMoreMatchingChildren ? "partialMatch-" : "nonMatch-" : "", {[`${Caf.toString(p)}${Caf.toString(path)}`]: parts}) : this.nonMatch ? {nonMatch: merge({offset: [this.offset, this.ruleName], pattern: `${Caf.toString(((temp = Caf.exists(base = this.pattern) && base.pattern) != null ? temp : Caf.exists(base1 = this.ruleVariant) && base1.pattern))}`})} : verbose ? {token: {offset: this.offset, length: this.matchLength, text: this.text, pattern: `${Caf.toString(Caf.exists(base2 = this.pattern) && base2.pattern)}`, class: this.class.getName(), ruleName: this.ruleName}} : this.text;}, detailedInspectedObjects: function() {let matches, children, ret; ({matches} = this); return (matches.length > 0) ? (children = Caf.array(matches, (match) => match.detailedInspectedObjects), ret = {}, ret[this.name] = (children.length === 1) ? children[0] : children, ret) : this.text;}, plainObjects: function() {let base; return ((Caf.exists(base = this._matches) && base.length) > 0) ? ([{inspect: () => this.class.getName()}]).concat(Caf.array(this.matches, (match) => match.getPlainObjects())) : this.text;}}); this.prototype.find = function(searchName, out = []) {Caf.each2(this.matches, (m) => (m.getName() === searchName) ? out.push(m) : m.find(searchName, out)); return out;}; this.prototype.subparse = function(subSource, options) {return this._parser.subparse(subSource, merge(options, {parentNode: this}));}; this.prototype.addMatch = function(pattern, match) {if (!match) {return false;}; this._matches = push(this._matches, match); this._matchPatterns = push(this._matchPatterns, pattern); this._matchLength = match.nextOffset - this.offset; return true;}; this.prototype.applyLabels = function() {if (!this._matches || this._labelsApplied) {return;}; this._labelsApplied = true; return Caf.array(this._matches, (match, i) => {let pattern, label, ruleName, pluralLabel, pluralRuleName; pattern = this._matchPatterns[i]; match._parent = this; if (pattern) {({label, ruleName} = pattern); match._pattern = pattern; match._label = label; match._ruleName = ruleName;}; if (label) {match._pluralLabel = pluralLabel = this.parser.pluralize(label);}; if (ruleName) {match._pluralRuleName = pluralRuleName = this.parser.pluralize(ruleName);}; label || (label = ruleName); pluralLabel || (pluralLabel = pluralRuleName); if (label && !(match instanceof Nodes.EmptyNode)) {this._bindToLabelLists(pluralLabel, match); this._bindToSingleLabels(label, match);}; return match.applyLabels();});}; this.prototype._bindToLabelLists = function(pluralLabel, match) {return !(this.__proto__[pluralLabel] != null) ? this[pluralLabel] = push(this[pluralLabel], match) : undefined;}; this.prototype._bindToSingleLabels = function(label, match) {return !(this.__proto__[label] != null) ? this[label] = match : undefined;}; this.prototype._addNonMatch = function(node) {return (this._nonMatches || (this._nonMatches = [])).push(node);}; this.prototype._addToParentAsNonMatch = function() {if (this._matchLength === 0) {this._matchLength = 1;}; return this.parent ? this.parent.matches ? (!(0 <= this.parent.matches.indexOf(this)) ? (this._nonMatch = true, this.parent.matches.push(this), this.parent._presentMatches = null, (this.parent._matchLength === 0) ? this.parent._matchLength = 1 : undefined) : undefined, this.parent._addToParentAsNonMatch()) : this : this;};});});});
//# sourceMappingURL=Node.js.map
