"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "Error", "EmptyOptionalNode", "EmptyNode", "isPlainObject", "isString", "RegExp", "isRegExp", "inspect", "Node"], [global, require('art-standard-lib'), require('art-class-system'), require('./Nodes')], (BaseClass, Error, EmptyOptionalNode, EmptyNode, isPlainObject, isString, RegExp, isRegExp, inspect, Node) => {let PatternElement; return PatternElement = Caf.defClass(class PatternElement extends BaseClass {constructor(pattern, options) {super(...arguments); this.pattern = pattern; options != null ? options : options = {}; this.ruleVariant = options.ruleVariant; this.parse = null; this._init();};}, function(PatternElement, classSuper, instanceSuper) {let escapeRegExp; this.escapeRegExp = escapeRegExp = function(str) {return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");}; this.regExpRegExp = /\/((?:[^\\\/]|\\.)+)\//; this.ruleRegExp = /([a-zA-Z0-9_]+)/; this.singleQuotedStringRegExp = /'((?:[^\\']|\\.)+)'/; this.doubleQuotedStringRegExp = /"((?:[^\\"]|\\.)+)"/; this.labelRegExp = /([a-zA-Z0-9_]+)\:/; this.patternElementRegExp = RegExp(`(?:${Caf.toString(this.labelRegExp.source)})?([!&])?(?:${Caf.toString(this.ruleRegExp.source)}|${Caf.toString(this.regExpRegExp.source)}|${Caf.toString(this.singleQuotedStringRegExp.source)}|${Caf.toString(this.doubleQuotedStringRegExp.source)})([?*+])?`); this.allPatternElementsRegExp = RegExp(`${Caf.toString(this.patternElementRegExp.source)}`, 'g'); this.prototype.toString = function() {return `PatternElement(${Caf.toString(this.pattern)})`;}; this.getter("isTokenPattern"); this.property({label: null, optional: false, negative: false, couldMatch: false, zeroOrMore: false, oneOrMore: false, pattern: null, ruleName: null}); this.getter({isBasicRulePattern: function() {return this.ruleName && !this.optional && !this.negative && !this.zeroOrMore && !this.oneOrMore && !this.couldMatch;}, inspectedObjects: function() {return {PatternElement: this.props};}, props: function() {let props; props = {pattern: this.pattern}; if (this.ruleVariant) {props.ruleVariant = this.ruleVariant.inspectedObjects;}; if (this.ruleName) {props.ruleName = this.ruleName;}; if (this.negative) {props.negative = true;}; if (this.zeroOrMore) {props.zeroOrMore = true;}; if (this.oneOrMore) {props.oneOrMore = true;}; if (this.couldMatch) {props.couldMatch = true;}; return props;}}); this.prototype.parse = function(parentNode) {return (() => {throw new Error("should be overridden");})();}; this.prototype.parseInto = function(parentNode) {return !!parentNode.addMatch(this, this.parse(parentNode));}; this.prototype._applyParseFlags = function() {let singleParser, m; singleParser = this.parse; m = undefined; if (this._optional) {this.parse = (parentNode) => {let match; return (match = singleParser(parentNode)) ? match : new EmptyOptionalNode(parentNode);};}; if (this._negative) {this.parse = (parentNode) => parentNode.parser._matchNegative(() => {let match; return (match = singleParser(parentNode)) ? null : new EmptyNode(parentNode);});}; if (this.couldMatch) {this.parse = (parentNode) => singleParser(parentNode) ? new EmptyNode(parentNode) : undefined;}; if (this._zeroOrMore) {this.parseInto = (parentNode) => {let matchCount; matchCount = 0; while (parentNode.addMatch(this, m = singleParser(parentNode))) {matchCount++; if (m.matchLength === 0) {break;};}; return true;};}; return this._oneOrMore ? this.parseInto = (parentNode) => {let matchCount; matchCount = 0; while (parentNode.addMatch(this, m = singleParser(parentNode))) {matchCount++; if (m.matchLength === 0) {break;};}; return matchCount > 0;} : undefined;}; this.prototype._init = function() {let pattern, __, label, prefix, ruleName, regExp, singleQuotedString, doubleQuotedString, suffix, res, string; this.parse = this.label = this.ruleName = null; this.negative = this.couldMatch = this.oneOrMore = this.optional = this.zeroOrMore = false; this._isTokenPattern = false; ({pattern} = this); if (isPlainObject(pattern)) {this._initPlainObject(pattern);} else {if (isString(pattern)) {([__, label, prefix, ruleName, regExp, singleQuotedString, doubleQuotedString, suffix] = res = pattern.match(PatternElement.patternElementRegExp)); this.label = label; this.ruleName = ruleName; if (prefix && suffix) {throw new Error("pattern can only have one prefix: !/& or one suffix: ?/+/*");}; switch (prefix) {case "!": this.negative = true; break; case "&": this.couldMatch = true;}; switch (suffix) {case "?": this.optional = true; break; case "+": this.oneOrMore = true; break; case "*": this.zeroOrMore = true;}; string = singleQuotedString || doubleQuotedString; if (this.ruleName) {this._initRule(this.ruleName);} else {if (regExp) {this._initRegExp(new RegExp(regExp));} else {if (string) {this._initRegExp(new RegExp(escapeRegExp(string)));} else {throw new Error(`invalid pattern: ${Caf.toString(pattern)}`);};};};} else {if (isRegExp(pattern)) {this._initRegExp(pattern);} else {throw new Error(`invalid pattern type: ${Caf.toString(inspect(pattern))}`);};};}; return this._applyParseFlags();}; this.prototype._initPlainObject = function(plainObject) {let parseInto; this.negative = plainObject.negative; this.oneOrMore = plainObject.oneOrMore; this.zeroOrMore = plainObject.zeroOrMore; this.optional = plainObject.optional; this.parse = plainObject.parse; parseInto = plainObject.parseInto; if (parseInto) {this.parseInto = parseInto;}; return !(this.parse || parseInto) ? (() => {throw new Error("plain-object pattern definition requires 'parse' or 'parseInto'");})() : undefined;}; this.prototype._initRule = function(ruleName) {let matchRule; matchRule = null; return this.parse = (parentNode) => {matchRule || (matchRule = parentNode.parser.getRule(ruleName)); return matchRule.parse(parentNode);};}; this.prototype._initRegExp = function(regExp) {let flags; this._isTokenPattern = true; flags = "yg"; if (regExp.ignoreCase) {flags += "i";}; regExp = RegExp(regExp.source, flags); return this.parse = (parentNode) => {let nextOffset, source; ({nextOffset, source} = parentNode); regExp.lastIndex = nextOffset; return regExp.test(source) ? new Node(parentNode, {offset: nextOffset, matchLength: regExp.lastIndex - nextOffset}) : undefined;};};});});});
//# sourceMappingURL=PatternElement.js.map
