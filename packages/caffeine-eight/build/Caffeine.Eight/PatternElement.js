// Generated by CoffeeScript 1.12.7
(function() {
  var EmptyNode, EmptyOptionalNode, Node, PatternElement, inspect, isPlainObject, isRegExp, isString, log, ref, ref1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./Nodes'), Node = ref.Node, EmptyNode = ref.EmptyNode, EmptyOptionalNode = ref.EmptyOptionalNode;

  ref1 = require('art-standard-lib'), isPlainObject = ref1.isPlainObject, isString = ref1.isString, isRegExp = ref1.isRegExp, inspect = ref1.inspect, log = ref1.log;

  module.exports = PatternElement = (function(superClass) {
    var escapeRegExp;

    extend(PatternElement, superClass);

    PatternElement.escapeRegExp = escapeRegExp = function(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    };

    PatternElement.regExpRegExp = /\/((?:[^\\\/]|\\.)+)\//;

    PatternElement.ruleRegExp = /([a-zA-Z0-9_]+)/;

    PatternElement.singleQuotedStringRegExp = /'((?:[^\\']|\\.)+)'/;

    PatternElement.doubleQuotedStringRegExp = /"((?:[^\\"]|\\.)+)"/;

    PatternElement.labelRegExp = /([a-zA-Z0-9_]+)\:/;

    PatternElement.patternElementRegExp = RegExp("(?:" + PatternElement.labelRegExp.source + ")?([!&])?(?:" + PatternElement.ruleRegExp.source + "|" + PatternElement.regExpRegExp.source + "|" + PatternElement.singleQuotedStringRegExp.source + "|" + PatternElement.doubleQuotedStringRegExp.source + ")([?*+])?");

    PatternElement.allPatternElementsRegExp = RegExp("" + PatternElement.patternElementRegExp.source, "g");

    function PatternElement(pattern1, arg) {
      this.pattern = pattern1;
      this.ruleVariant = (arg != null ? arg : {}).ruleVariant;
      PatternElement.__super__.constructor.apply(this, arguments);
      this.parse = null;
      this._init();
    }

    PatternElement.prototype.toString = function() {
      return "PatternElement(" + this.pattern + ")";
    };

    PatternElement.getter("isTokenPattern");

    PatternElement.property({
      label: null,
      optional: false,
      negative: false,
      couldMatch: false,
      zeroOrMore: false,
      oneOrMore: false,
      pattern: null,
      ruleName: null
    });

    PatternElement.getter({
      isBasicRulePattern: function() {
        return this.ruleName && !this.optional && !this.negative && !this.zeroOrMore && !this.oneOrMore && !this.couldMatch;
      },
      inspectedObjects: function() {
        return {
          PatternElement: this.props
        };
      },
      props: function() {
        var props;
        props = {
          pattern: this.pattern
        };
        if (this.ruleVariant) {
          props.ruleVariant = this.ruleVariant.inspectedObjects;
        }
        if (this.ruleName) {
          props.ruleName = this.ruleName;
        }
        if (this.negative) {
          props.negative = true;
        }
        if (this.zeroOrMore) {
          props.zeroOrMore = true;
        }
        if (this.oneOrMore) {
          props.oneOrMore = true;
        }
        if (this.couldMatch) {
          props.couldMatch = true;
        }
        return props;
      }
    });

    PatternElement.prototype.parse = function(parentNode) {
      throw new Error("should be overridden");
    };

    PatternElement.prototype.parseInto = function(parentNode) {
      return !!parentNode.addMatch(this, this.parse(parentNode));
    };

    PatternElement.prototype._applyParseFlags = function() {
      var singleParser;
      singleParser = this.parse;
      if (this._optional) {
        this.parse = function(parentNode) {
          var match;
          if (match = singleParser(parentNode)) {
            return match;
          } else {
            return new EmptyOptionalNode(parentNode);
          }
        };
      }
      if (this._negative) {
        this.parse = function(parentNode) {
          return parentNode.parser._matchNegative(function() {
            var match;
            if (match = singleParser(parentNode)) {
              return null;
            } else {
              return new EmptyNode(parentNode);
            }
          });
        };
      }
      if (this.couldMatch) {
        this.parse = function(parentNode) {
          if (singleParser(parentNode)) {
            return new EmptyNode(parentNode);
          }
        };
      }
      if (this._zeroOrMore) {
        this.parseInto = (function(_this) {
          return function(parentNode) {
            var m, matchCount;
            matchCount = 0;
            while (parentNode.addMatch(_this, m = singleParser(parentNode))) {
              matchCount++;
              if (m.matchLength === 0) {
                break;
              }
            }
            return true;
          };
        })(this);
      }
      if (this._oneOrMore) {
        return this.parseInto = (function(_this) {
          return function(parentNode) {
            var m, matchCount;
            matchCount = 0;
            while (parentNode.addMatch(_this, m = singleParser(parentNode))) {
              matchCount++;
              if (m.matchLength === 0) {
                break;
              }
            }
            return matchCount > 0;
          };
        })(this);
      }
    };

    PatternElement.prototype._init = function() {
      var __, doubleQuotedString, pattern, prefix, ref2, regExp, res, singleQuotedString, string, suffix;
      this.parse = this.label = this.ruleName = null;
      this.negative = this.couldMatch = this.oneOrMore = this.optional = this.zeroOrMore = false;
      this._isTokenPattern = false;
      pattern = this.pattern;
      if (isPlainObject(pattern)) {
        this._initPlainObject(pattern);
      } else if (isString(pattern)) {
        ref2 = res = pattern.match(PatternElement.patternElementRegExp), __ = ref2[0], this.label = ref2[1], prefix = ref2[2], this.ruleName = ref2[3], regExp = ref2[4], singleQuotedString = ref2[5], doubleQuotedString = ref2[6], suffix = ref2[7];
        if (prefix && suffix) {
          throw new Error("pattern can only have one prefix: !/& or one suffix: ?/+/*");
        }
        switch (prefix) {
          case "!":
            this.negative = true;
            break;
          case "&":
            this.couldMatch = true;
        }
        switch (suffix) {
          case "?":
            this.optional = true;
            break;
          case "+":
            this.oneOrMore = true;
            break;
          case "*":
            this.zeroOrMore = true;
        }
        string = singleQuotedString || doubleQuotedString;
        if (this.ruleName) {
          this._initRule(this.ruleName);
        } else if (regExp) {
          this._initRegExp(new RegExp(regExp));
        } else if (string) {
          this._initRegExp(new RegExp(escapeRegExp(string)));
        } else {
          throw new Error("invalid pattern: " + pattern);
        }
      } else if (isRegExp(pattern)) {
        this._initRegExp(pattern);
      } else {
        throw new Error("invalid pattern type: " + (inspect(pattern)));
      }
      return this._applyParseFlags();
    };

    PatternElement.prototype._initPlainObject = function(object) {
      var parseInto;
      this.negative = object.negative, this.oneOrMore = object.oneOrMore, this.zeroOrMore = object.zeroOrMore, this.optional = object.optional, this.parse = object.parse, parseInto = object.parseInto;
      if (parseInto) {
        this.parseInto = parseInto;
      }
      if (!(this.parse || parseInto)) {
        throw new Error("plain-object pattern definition requires 'parse' or 'parseInto'");
      }
    };

    PatternElement.prototype._initRule = function(ruleName) {
      var matchRule;
      matchRule = null;
      return this.parse = function(parentNode) {
        matchRule || (matchRule = parentNode.parser.getRule(ruleName));
        return matchRule.parse(parentNode);
      };
    };


    /*
    NOTE: regExp.test is 3x faster than .exec in Safari, but about the
      same in node/chrome. Safari is 2.5x faster than Chrome/Node in this.
    
      Regexp must have the global flag set, even if we are using the y-flag,
      to make .test() set .lastIndex correctly.
    
    SEE: https://jsperf.com/regex-match-length
     */

    PatternElement.prototype._initRegExp = function(regExp) {
      var flags;
      this._isTokenPattern = true;
      flags = "yg";
      if (regExp.ignoreCase) {
        flags += "i";
      }
      regExp = RegExp(regExp.source, flags);
      return this.parse = function(parentNode) {
        var nextOffset, source;
        nextOffset = parentNode.nextOffset, source = parentNode.source;
        regExp.lastIndex = nextOffset;
        if (regExp.test(source)) {
          return new Node(parentNode, {
            offset: nextOffset,
            matchLength: regExp.lastIndex - nextOffset
          });
        }
      };
    };

    return PatternElement;

  })(require("art-class-system").BaseClass);

}).call(this);

//# sourceMappingURL=PatternElement.js.map
