// Generated by CoffeeScript 1.12.7
(function() {
  var CaffeineEightCompileError, Node, NonMatch, ParserCoffee, Rule, ScratchNode, SourceLineColumnMap, Stats, compactFlatten, firstLines, formattedInspect, inspect, inspectLean, isClass, isFunction, isNumber, isPlainArray, isPlainObject, lastLines, log, max, merge, mergeInto, objectHasKeys, objectLength, objectWithout, peek, pluralize, presentSourceLocation, pushIfNotPresent, ref, ref1, ref2, uniqueValues, upperCamelCase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Rule = require('./Rule');

  ref = require('./Nodes'), Node = ref.Node, ScratchNode = ref.ScratchNode;

  NonMatch = require('./NonMatch');

  Stats = require('./Stats');

  SourceLineColumnMap = require('./SourceLineColumnMap');

  ref1 = require('art-standard-lib'), isNumber = ref1.isNumber, isFunction = ref1.isFunction, peek = ref1.peek, log = ref1.log, isPlainObject = ref1.isPlainObject, isPlainArray = ref1.isPlainArray, merge = ref1.merge, compactFlatten = ref1.compactFlatten, objectLength = ref1.objectLength, inspect = ref1.inspect, inspectLean = ref1.inspectLean, pluralize = ref1.pluralize, isClass = ref1.isClass, isPlainArray = ref1.isPlainArray, upperCamelCase = ref1.upperCamelCase, mergeInto = ref1.mergeInto, objectWithout = ref1.objectWithout, uniqueValues = ref1.uniqueValues, formattedInspect = ref1.formattedInspect, max = ref1.max, inspect = ref1.inspect, pushIfNotPresent = ref1.pushIfNotPresent, uniqueValues = ref1.uniqueValues, objectHasKeys = ref1.objectHasKeys;

  ref2 = require('./Lib'), firstLines = ref2.firstLines, lastLines = ref2.lastLines, presentSourceLocation = ref2.presentSourceLocation;

  CaffeineEightCompileError = require('./CaffeineEightCompileError');

  module.exports = ParserCoffee = (function(superClass) {
    var addToExpectingInfo;

    extend(ParserCoffee, superClass);

    ParserCoffee.repl = function(options) {
      return (require('./Repl')).caffeineEightRepl(this, options);
    };

    ParserCoffee.parse = function(_source, options) {
      this._source = _source;
      if (options == null) {
        options = {};
      }
      return (new this).parse(this._source, options);
    };

    ParserCoffee.classGetter({
      rootRuleName: function() {
        return this._rootRuleName || "root";
      },
      rootRule: function() {
        return this.getRules()[this._rootRuleName];
      }
    });

    ParserCoffee.extendableProperty({
      rules: {}
    }, {
      noSetter: true,
      extend: function(extendableRules, newRules) {
        var newRule, ruleName;
        for (ruleName in newRules) {
          newRule = newRules[ruleName];
          extendableRules[ruleName] = newRule.clone();
        }
        return extendableRules;
      }
    });

    ParserCoffee.getNodeBaseClass = function() {
      return this._nodeBaseClass || (this._nodeBaseClass = isPlainObject(this.nodeBaseClass) ? Node.createSubclass(merge({
        name: this.getName() + "NodeBaseClass"
      }, this.nodeBaseClass)) : this.nodeBaseClass || Node);
    };

    ParserCoffee.property("subparseInfo options");

    ParserCoffee.getter("source parser", {
      rootRuleName: function() {
        return this["class"].getRootRuleName();
      },
      rootRule: function() {
        return this["class"].getRootRule();
      },
      nextOffset: function() {
        return 0;
      },
      rootParser: function() {
        var ref3;
        return ((ref3 = this.parentParser) != null ? ref3.rootParser : void 0) || this;
      },
      rootSource: function() {
        return this.rootParser.source;
      },
      ancestors: function(into) {
        into.push(this);
        return into;
      },
      parseInfo: function() {
        return "Parser";
      }
    });

    function ParserCoffee() {
      ParserCoffee.__super__.constructor.apply(this, arguments);
      this._options = null;
      this._parser = this;
      this._source = null;
      this._resetParserTracking();
    }

    ParserCoffee._pluralNames = {};

    ParserCoffee.pluralize = function(name) {
      var pluralName;
      if (!(pluralName = this._pluralNames[name])) {
        pluralName = pluralize(name);
        if (pluralName === name) {
          pluralName += "s";
        }
        this._pluralNames[name] = pluralName;
      }
      return pluralName;
    };

    ParserCoffee.prototype.pluralize = function(name) {
      return this["class"].pluralize(name);
    };


    /*
    IN:
      subsource:
        any string what-so-ever
      options:
        [all of @parse's options plus:]
        parentNode: (required)
          the resulting Node's parent
    
        originalMatchLength: (required)
          matchLength from @source that subsource was generated from.
    
        originalOffset: starting offset in parentParser.source
    
        sourceMap: (subsourceOffset) -> parentSourceOffset
    
      The original source we are sub-parsing from must be:
    
        parentNode.getNextText originalMatchLength
    
    OUT: a Node with offset and matchLength
     */

    ParserCoffee.prototype.subparse = function(subsource, options) {
      var failureIndex, k, match, matchLength, nonMatch, offset, originalMatchLength, originalOffset, parentNode, parser, ref3, rootNode, source, sourceMap, subparser;
      if (options == null) {
        options = {};
      }
      Stats.add("subparse");
      subparser = new this["class"];
      originalMatchLength = options.originalMatchLength, parentNode = options.parentNode, sourceMap = options.sourceMap, originalOffset = options.originalOffset;
      options.parentParser = this;
      options.sourceFile = this.options.sourceFile;
      if (match = subparser.parse(subsource, merge(options, {
        isSubparse: true,
        logParsingFailures: this._logParsingFailures
      }))) {
        offset = match.offset, matchLength = match.matchLength, source = match.source, parser = match.parser;
        match.subparseInfo = {
          offset: offset,
          matchLength: matchLength,
          source: source,
          parser: parser
        };
        if (match.matchLength < subsource.length) {
          originalMatchLength = (function() {
            if (sourceMap) {
              return sourceMap(match.matchLength) - parentNode.nextOffset;
            } else if (match.text === parentNode.getNextText(match.matchLength)) {
              return match.matchLength;
            } else {
              throw new Error("Subparse requires a sourceMap to determine the match-length in the parent text for partial-matches.");
            }
          })();
        }
        match.offset = parentNode.nextOffset;
        match.matchLength = originalMatchLength;
        match._parser = parentNode._parser;
        match._parent = parentNode;
        return match;
      } else {
        failureIndex = subparser.failureIndexInParentParser;
        ref3 = subparser._nonMatches;
        for (k in ref3) {
          nonMatch = ref3[k];
          rootNode = nonMatch.node;
          while (rootNode !== parentNode && rootNode.parent instanceof Node) {
            rootNode = rootNode.parent;
          }
          if (rootNode !== parentNode) {
            rootNode._parent = parentNode;
          }
          if (this._logParsingFailures) {
            this._addNonMatch(failureIndex, nonMatch);
          } else {
            this._failureIndex = max(this._failureIndex, failureIndex);
          }
        }
        return null;
      }
    };

    ParserCoffee.prototype.offsetInParentParserSource = function(suboffset) {
      var originalOffset, ref3, ref4, sourceMap;
      ref3 = this.options, sourceMap = ref3.sourceMap, originalOffset = (ref4 = ref3.originalOffset) != null ? ref4 : 0;
      if (sourceMap) {
        if (!(suboffset <= this.source.length)) {
          throw new Error("suboffset (" + suboffset + ") > source.length (" + this.source.length + ")");
        }
        return sourceMap(suboffset);
      } else if (this.parentParser) {
        return this.options.originalOffset + suboffset;
      } else {
        return suboffset;
      }
    };

    ParserCoffee.prototype.offsetInRootParserSource = function(suboffset) {
      if (this.parentParser) {
        return this.parentParser.offsetInRootParserSource(this.offsetInParentParserSource(suboffset));
      } else {
        return suboffset;
      }
    };

    ParserCoffee.getter({
      failureIndexInParentParser: function() {
        return this.offsetInParentParserSource(this._failureIndex);
      }
    });

    ParserCoffee.prototype.colorString = function(clr, str) {
      if (this.options.color) {
        return ("" + str)[clr];
      } else {
        return str;
      }
    };


    /*
    OUT: on success, root Node of the parse tree, else null
    options:
      allowPartialMatch: true/false
      color:    (default: false)  show errors in color (console colors)
      maxLines: (default: 10)     max total source lines to show when showing errors
     */

    ParserCoffee.prototype.parse = function(_source, options1) {
      var allowPartialMatch, isSubparse, logParsingFailures, ref3, rootParseTreeNode, rule, startRule;
      this._source = _source;
      this.options = options1 != null ? options1 : {};
      ref3 = this.options, this.parentParser = ref3.parentParser, allowPartialMatch = ref3.allowPartialMatch, rule = ref3.rule, isSubparse = ref3.isSubparse, logParsingFailures = ref3.logParsingFailures;
      startRule = this.getRule(rule);
      this._resetParserTracking();
      this._logParsingFailures = logParsingFailures;
      try {
        if ((rootParseTreeNode = startRule.parse(this)) && (rootParseTreeNode.matchLength === this._source.length || (allowPartialMatch && rootParseTreeNode.matchLength > 0))) {
          if (!isSubparse) {
            rootParseTreeNode.applyLabels();
          }
          return rootParseTreeNode;
        } else {
          if (!isSubparse) {
            if (logParsingFailures) {
              throw this.generateCompileError(merge(this.options, {
                rootParseTreeNode: rootParseTreeNode
              }));
            } else {
              return this.parse(this._source, merge(this.options, {
                logParsingFailures: true
              }));
            }
          }
        }
      } finally {
        if (!isSubparse) {
          ScratchNode.resetAll();
        }
      }
    };

    ParserCoffee.prototype.generateCompileError = function(options) {
      var info, message, rootParseTreeNode;
      message = options.message, info = options.info, rootParseTreeNode = options.rootParseTreeNode;
      return new CaffeineEightCompileError(compactFlatten([(rootParseTreeNode != null ? rootParseTreeNode.matchLength : void 0) < this._source.length ? this.colorString("gray", (this["class"].name + " only parsed: ") + this.colorString("black", (rootParseTreeNode.matchLength + " of " + this._source.length + " ") + this.colorString("gray", "characters"))) : void 0, this.getParseFailureInfo(options), message]).join("\n"), merge(this.getParseFailureInfoObject(options), info));
    };

    ParserCoffee.prototype.getRule = function(ruleName) {
      var rule;
      ruleName || (ruleName = this.rootRuleName);
      if (!ruleName) {
        throw new Error("No root rule defined.");
      }
      if (!(rule = this.rules[ruleName])) {
        throw new Error("Could not find rule: " + ruleName);
      }
      return rule;
    };

    addToExpectingInfo = function(node, into, value) {
      var m, name1, p, pm, ref3;
      if (node.parent) {
        into = addToExpectingInfo(node.parent, into);
      }
      return into[name1 = node.parseInfo] || (into[name1] = value ? value : (p = {}, ((ref3 = (pm = node.presentMatches)) != null ? ref3.length : void 0) > 0 ? p.matches = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = pm.length; i < len; i++) {
          m = pm[i];
          results.push(m.parseInfo);
        }
        return results;
      })() : void 0, p));
    };

    ParserCoffee.getter("nonMatches", {
      sourceFile: function() {
        return this.options.sourceFile;
      },
      failureUrl: function(failureIndex) {
        if (failureIndex == null) {
          failureIndex = this._failureIndex;
        }
        return (this.options.sourceFile || '') + ":" + (this.getLineColumnString(failureIndex));
      },
      parseFailureInfoObject: function(options) {
        var failureIndex, ref3;
        failureIndex = (ref3 = options != null ? options.failureIndex : void 0) != null ? ref3 : this._failureIndex;
        if (this.parentParser) {
          return this.rootParser.getParseFailureInfoObject({
            failureIndex: this.offsetInRootParserSource(failureIndex)
          });
        } else {
          return merge({
            sourceFile: this.options.sourceFile,
            failureIndex: failureIndex,
            location: this.getFailureUrl(failureIndex),
            expectingInfo: failureIndex === this._failureIndex ? this.expectingInfo : void 0
          }, this.getLineColumn(failureIndex));
        }
      },
      parseFailureInfo: function(options) {
        var error, errorType, failureIndex, failureOffset, ref3, ref4, verbose;
        if (options == null) {
          options = {};
        }
        if (!this._source) {
          return;
        }
        error = options.error, failureOffset = options.failureOffset, failureIndex = (ref3 = options.failureIndex) != null ? ref3 : this._failureIndex, verbose = options.verbose, errorType = (ref4 = options.errorType) != null ? ref4 : "Parsing";
        if (failureOffset != null) {
          throw new Error("DEPRICATED: failureOffset");
        }
        if (this.parentParser) {
          return this.rootParser.getParseFailureInfo({
            failureIndex: this.offsetInRootParserSource(failureIndex),
            verbose: verbose,
            errorType: errorType
          });
        } else {
          return compactFlatten([
            this.colorString("gray", errorType + " error at " + (this.colorString("red", this.getFailureUrl(failureIndex)))), "", this.colorString("gray", "Source:"), this.colorString("gray", "..."), presentSourceLocation(this._source, failureIndex, this.options), this.colorString("gray", "..."), "", this.expectingInfo ? formattedInspect(this.expectingInfo, options) : error, verbose ? formattedInspect({
              "partial-parse-tree": this.partialParseTree
            }, options) : void 0, ""
          ]).join("\n");
        }
      },
      partialParseTreeLeafNodes: function() {
        if (this._partialParseTreeNodes) {
          return this._partialParseTreeNodes;
        }
        this.getPartialParseTree();
        return this._partialParseTreeNodes;
      },
      partialParseTree: function() {
        var expectingInfoTree, k, n, node, patternElement, rootNode;
        if (this._partialParseTree) {
          return this._partialParseTree;
        }
        expectingInfoTree = {};
        this._partialParseTreeNodes = (function() {
          var ref3, ref4, results;
          ref3 = this._nonMatches;
          results = [];
          for (k in ref3) {
            ref4 = ref3[k], patternElement = ref4.patternElement, node = ref4.node;
            addToExpectingInfo(node, expectingInfoTree, patternElement.pattern.toString());
            n = new Node(node);
            n.pattern = patternElement;
            rootNode = n._addToParentAsNonMatch();
            results.push(n);
          }
          return results;
        }).call(this);
        return this._partialParseTree = rootNode;
      },
      expectingInfo: function() {
        var child, couldMatchRuleNames, expecting, firstPartialMatchParent, i, j, l, len, len1, len2, node, out, partialMatchingParents, pmp, ref3, ref4, ruleName, v;
        if (!(objectLength(this._nonMatches) > 0)) {
          return null;
        }
        if (this._expectingInfo) {
          return this._expectingInfo;
        }

        /*
        I know how to do this right!
        
        1) I want to add all the non-match nodes to the parse-tree
        2) I want to further improve the parse-tree inspect
          - it may be time to do a custom inspect
         */
        partialMatchingParents = [];
        ref3 = this.partialParseTreeLeafNodes;
        for (i = 0, len = ref3.length; i < len; i++) {
          node = ref3[i];
          firstPartialMatchParent = node.firstPartialMatchParent;
          pushIfNotPresent(partialMatchingParents, firstPartialMatchParent);
        }
        couldMatchRuleNames = [];
        expecting = {};
        for (j = 0, len1 = partialMatchingParents.length; j < len1; j++) {
          pmp = partialMatchingParents[j];
          ref4 = pmp.matches;
          for (l = 0, len2 = ref4.length; l < len2; l++) {
            child = ref4[l];
            if (!(child.isNonMatch && child.nonMatchingLeaf)) {
              continue;
            }
            if (ruleName = child.nonMatchingLeaf.ruleNameOrNull) {
              couldMatchRuleNames.push(ruleName);
            }
            expecting[child.nonMatchingLeaf.ruleNameOrPattern] = {
              "to-continue": pmp.ruleName,
              "started-at": this.getLineColumnString(pmp.absoluteOffset)
            };
          }
        }
        return this._expectingInfo = (function() {
          var len3, len4, o, q, ref5;
          if (objectHasKeys(expecting)) {
            out = {
              expecting: expecting
            };
            if (couldMatchRuleNames.length > 1) {
              out.rules = {};
              for (o = 0, len3 = couldMatchRuleNames.length; o < len3; o++) {
                ruleName = couldMatchRuleNames[o];
                ref5 = this.rules[ruleName]._variants;
                for (q = 0, len4 = ref5.length; q < len4; q++) {
                  v = ref5[q];
                  out.rules[ruleName] = v.patternString;
                }
              }
            }
            return out;
          } else {
            return {
              expecting: "end of input"
            };
          }
        }).call(this);
      }
    });

    ParserCoffee.prototype.tryPatternElement = function(patternElement, parseIntoNode, ruleVariant) {
      Stats.add("tryPatternElement");
      if (patternElement.parseInto(parseIntoNode)) {
        return true;
      } else {
        this._logParsingFailure(parseIntoNode, patternElement);
        return false;
      }
    };

    ParserCoffee.prototype.getLineColumn = function(offset, into) {
      return (this._sourceLineColumnMap || (this._sourceLineColumnMap = new SourceLineColumnMap(this._source))).getLineColumn(offset, into);
    };

    ParserCoffee.prototype.getLineColumnString = function(offset, into) {
      var a, column, line, ref3;
      ref3 = a = this.getLineColumn(offset, into), line = ref3.line, column = ref3.column;
      return (line + 1) + ":" + (column + 1);
    };

    ParserCoffee.prototype._getRuleParseCache = function(ruleName) {
      var base;
      return (base = this._parseCache)[ruleName] || (base[ruleName] = {});
    };

    ParserCoffee.prototype._cached = function(ruleName, offset) {
      return this._getRuleParseCache(ruleName)[offset];
    };

    ParserCoffee.prototype._cacheMatch = function(ruleName, matchingNode) {
      Stats.add("cacheMatch");
      this._getRuleParseCache(ruleName)[matchingNode.offset] = matchingNode;
      return matchingNode;
    };

    ParserCoffee.prototype._cacheNoMatch = function(ruleName, offset) {
      Stats.add("cacheNoMatch");
      this._getRuleParseCache(ruleName)[offset] = "no_match";
      return null;
    };

    ParserCoffee.prototype._resetParserTracking = function() {
      this._activeRuleVariantParserOffsets = {};
      this._subparseInfo = null;
      this._logParsingFailures = false;
      this._partialParseTreeNodes = null;
      this._partialParseTree = null;
      this._matchingNegativeDepth = 0;
      this._parsingDidNotMatchEntireInput = false;
      this._failureIndex = 0;
      this._expectingInfo = null;
      this._nonMatches = {};
      this._parseCache = {};
      return this._parentParserRootOffset = null;
    };

    ParserCoffee.getter("activeRuleVariantParserOffsets activeRuleVariantParserAreLeftRecursive failureIndex", {
      isMatchingNegative: function() {
        return this._matchingNegativeDepth > 0;
      }
    });

    ParserCoffee.prototype._matchNegative = function(f) {
      var result;
      this._matchingNegativeDepth++;
      result = f();
      this._matchingNegativeDepth--;
      return result;
    };

    ParserCoffee.prototype._logParsingFailure = function(parseIntoNode, patternElement) {
      var nextOffset;
      nextOffset = parseIntoNode.nextOffset;
      if (!(this._matchingNegativeDepth === 0 && nextOffset >= this._failureIndex && patternElement.isTokenPattern)) {
        return;
      }
      if (this._logParsingFailures) {
        parseIntoNode = parseIntoNode.getRealNode();
        return this._addNonMatch(nextOffset, new NonMatch(parseIntoNode, patternElement));
      } else {
        return this._failureIndex = nextOffset;
      }
    };

    ParserCoffee.prototype._addNonMatch = function(offset, nonMatch) {
      if (offset > this._failureIndex) {
        this._failureIndex = offset;
        this._nonMatches = {};
      }
      return this._nonMatches[nonMatch] = nonMatch;
    };

    ParserCoffee._extendRule = function(ruleName) {
      var rule;
      if (rule = this.extendRules()[ruleName]) {
        if (rule.definedInClass !== this) {
          return rule.clone();
        } else {
          return rule;
        }
      } else {
        return this._newRule(ruleName);
      }
    };

    ParserCoffee._newRule = function(ruleName) {
      return new Rule(ruleName, this);
    };

    ParserCoffee._addRule = function(ruleName, variantDefinitions, addPriorityVariants) {
      if (variantDefinitions.root) {
        if (this._rootRuleName) {
          throw new Error("root rule already defined! was: " + this._rootRuleName + ", wanted: " + ruleName);
        }
        if (ruleName !== "root") {
          log.warn("DEPRICATED: root rule should always be called 'root' now");
        }
        this._rootRuleName = ruleName;
      }
      return this._replaceRule(this._extendRule(ruleName), ruleName, variantDefinitions, addPriorityVariants);
    };


    /* _replaceRule
      IN:
        rule: <Rule>
        ruleName: <String>
        variantDefinitions: <Array<Object:definition>>
    
      definition:
        pattern: <String|RegExp>
        ... additional props are added to the Rule's Node class
     */

    ParserCoffee._replaceRule = function(rule, ruleName, variantDefinitions, addPriorityVariants) {
      var definition, i, len, results;
      this.extendRules()[ruleName] = rule;
      results = [];
      for (i = 0, len = variantDefinitions.length; i < len; i++) {
        definition = variantDefinitions[i];
        results.push(rule.addVariant(definition, addPriorityVariants));
      }
      return results;
    };

    return ParserCoffee;

  })(require("art-class-system").BaseClass);

}).call(this);

//# sourceMappingURL=ParserCoffee.js.map
