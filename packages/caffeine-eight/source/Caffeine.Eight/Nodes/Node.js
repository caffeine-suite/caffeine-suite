// Generated by CoffeeScript 1.12.7
(function() {
  var BaseClass, Node, Nodes, Stats, array, arrayWith, compactFlatten, inspectedObjectLiteral, isPlainArray, isPlainObject, log, merge, mergeInto, objectWithout, peek, push, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), arrayWith = ref.arrayWith, array = ref.array, peek = ref.peek, log = ref.log, push = ref.push, compactFlatten = ref.compactFlatten, objectWithout = ref.objectWithout, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, inspectedObjectLiteral = ref.inspectedObjectLiteral, merge = ref.merge, mergeInto = ref.mergeInto;

  Nodes = require('./namespace');

  BaseClass = require('art-class-system').BaseClass;

  Stats = require('../Stats');

  module.exports = Node = (function(superClass) {
    var emptyArray;

    extend(Node, superClass);

    function Node(parent, options) {
      var ref1;
      Node.__super__.constructor.apply(this, arguments);
      Stats.add("newNode");
      this._parent = parent;
      this._parser = parent._parser;
      this._absoluteOffset = -1;
      this._offset = ((ref1 = options != null ? options.offset : void 0) != null ? ref1 : this._parent.getNextOffset()) | 0;
      if (this._offset > this._parser.source.length) {
        throw new Error("bad offset " + this.inspectedName + " - offset:" + this._offset + " > sourceLength:" + this._parser.source.length);
      }
      this._matchLength = 0;
      this._ruleName = this._pluralRuleName = this._label = this._pluralLabel = this._pattern = this._nonMatches = this._ruleVariant = this._matches = this._matchPatterns = null;
      this._labelsApplied = this._nonMatch = false;
      if (options) {
        this._matchLength = (options.matchLength || 0) | 0;
        this._ruleVariant = options.ruleVariant;
        this._matches = options.matches;
        this._matchPatterns = options.matchPatterns;
      }
    }

    Node._createSubclassBase = function() {
      var NodeSubclass;
      return NodeSubclass = (function(superClass1) {
        extend(NodeSubclass, superClass1);

        function NodeSubclass() {
          return NodeSubclass.__super__.constructor.apply(this, arguments);
        }

        return NodeSubclass;

      })(this);
    };

    Node.createSubclass = function(options) {
      var klass;
      klass = this._createSubclassBase();
      if (options.name) {
        klass._name = klass.prototype._name = options.name;
      }
      if (options.ruleVarient) {
        klass.ruleVarient = options.ruleVarient;
        klass.rule = klass.ruleVariant.rule;
      }
      mergeInto(klass.prototype, objectWithout(options, "getter"));
      if (options.getter) {
        klass.getter(options.getter);
      }
      return klass;
    };

    Node.prototype.toString = function() {
      return this.text;
    };

    Node.prototype.getSourceLineColumn = function(into) {
      return this.parser.getLineColumn(this.offset, into);
    };

    emptyArray = [];

    Node.setter("matches offset matchLength ruleVariant pattern matchPatterns");

    Node.getter("parent parser offset matchLength matchPatterns label pluralLabel ruleName pluralRuleName pattern nonMatch", {
      realNode: function() {
        return this;
      },
      name: function() {
        return this._name || this.ruleName || this["class"].getName();
      },
      present: function() {
        return this._matchLength > 0 || this._nonMatch;
      },
      matches: function() {
        return this._matches || (this._matches = []);
      },
      source: function() {
        return this._parser.source;
      },
      isRoot: function() {
        return this._parser === this._parent;
      },
      hasMatches: function() {
        var ref1;
        return ((ref1 = this._matches) != null ? ref1.length : void 0) > 0;
      },
      absoluteOffset: function() {
        if (this._absoluteOffset >= 0) {
          return this._absoluteOffset;
        } else {
          return this._absoluteOffset = this._parser.offsetInRootParserSource(this._offset);
        }
      },
      ancestors: function(into) {
        if (into == null) {
          into = [];
        }
        this.parent.getAncestors(into);
        into.push(this);
        return into;
      },
      sourceFile: function() {
        return this._parser.sourceFile;
      },
      parseInfo: function() {
        if (this.subparseInfo) {
          return "subparse:" + this.ruleName + ":" + this.offset;
        } else {
          return this.ruleName + ":" + this.offset;
        }
      },
      rulePath: function() {
        var ancestor, ancestorRuleNames;
        ancestorRuleNames = (function() {
          var j, len, ref1, results;
          ref1 = this.ancestors;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            ancestor = ref1[j];
            results.push(ancestor.parseInfo);
          }
          return results;
        }).call(this);
        return ancestorRuleNames.join(" > ");
      },
      nextOffset: function() {
        return this.offset + this.matchLength;
      },
      text: function() {
        var matchLength, offset, ref1, source;
        ref1 = this.subparseInfo || this, matchLength = ref1.matchLength, offset = ref1.offset, source = ref1.source;
        if (matchLength === 0) {
          return "";
        } else {
          return source.slice(offset, offset + matchLength);
        }
      },
      ruleVariant: function() {
        var ref1;
        return this._ruleVariant || ((ref1 = this._parent) != null ? ref1.ruleVariant : void 0);
      },
      ruleName: function() {
        var ref1;
        return this.ruleNameOrNull || ((ref1 = this.parent) != null ? ref1.ruleName : void 0) || ("" + (this.pattern || 'no rule'));
      },
      ruleNameOrNull: function() {
        var ref1, ref2;
        return ((ref1 = this["class"].rule) != null ? ref1.getName() : void 0) || ((ref2 = this._ruleVariant) != null ? ref2.rule.getName() : void 0);
      },
      ruleNameOrPattern: function() {
        var ref1;
        return this.ruleNameOrNull || ("" + (((ref1 = this.pattern) != null ? ref1.pattern : void 0) || 'no rule'));
      },
      isRuleNode: function() {
        return this["class"].rule;
      },
      isPassThrough: function() {
        var ref1;
        return (ref1 = this.ruleVariant) != null ? ref1.isPassThrough : void 0;
      },
      nonPassThrough: function() {
        var ref1;
        return !((ref1 = this.ruleVariant) != null ? ref1.isPassThrough : void 0);
      }
    });

    Node.prototype.getNextText = function(length) {
      var nextOffset;
      nextOffset = this.nextOffset;
      return this.source.slice(nextOffset, nextOffset + length);
    };

    Node.prototype.formattedInspect = function() {
      return "CUSTOM";
    };

    Node.getter({
      parseTreePath: function() {
        var ref1;
        return compactFlatten([(ref1 = this.parent) != null ? ref1.parseTreePath : void 0, this["class"].getName()]);
      },
      presentMatches: function() {
        var j, len, m, ref1, results;
        ref1 = this.matches;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          m = ref1[j];
          if (typeof m.getPresent === "function" ? m.getPresent() : void 0) {
            results.push(m);
          }
        }
        return results;
      },
      isNonMatch: function() {
        return !!this.nonMatch;
      },
      isPartialMatch: function() {
        var j, len, match, ref1;
        if (!this.nonMatch) {
          return false;
        }
        ref1 = this.presentMatches;
        for (j = 0, len = ref1.length; j < len; j++) {
          match = ref1[j];
          if (!match.nonMatch) {
            return true;
          }
        }
        return false;
      },
      isMatch: function() {
        return !this.nonMatch;
      },
      nonMatchingLeaf: function() {
        return this.nonMatch && (peek(this.matches)) || this;
      },
      firstPartialMatchParent: function() {
        if (this.parent === this.parser || this.isPartialMatch) {
          return this;
        } else {
          return this.parent.firstPartialMatchParent;
        }
      },
      inspectedName: function() {
        var l;
        return "" + ((l = this.label) ? l + ":" : "") + this.ruleName;
      },
      children: function() {
        var j, len, match, ref1, results;
        ref1 = this.presentMatches;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          match = ref1[j];
          if ((typeof match.getPresent === "function" ? match.getPresent() : void 0) && !match.nonMatch) {
            results.push(match);
          }
        }
        return results;
      },
      inspectedObjects: function(verbose) {
        var children, hasOneOrMoreMatchingChildren, label, match, matches, nonMatch, obj, parts, path, ref1, ref2, ref3, ref4, ref5, ruleName;
        match = this;
        matches = this.presentMatches;
        if (matches.length > 0) {
          path = [];
          while (matches.length === 1 && ((ref1 = matches[0].matches) != null ? ref1.length : void 0) > 0) {
            path.push(match.inspectedName);
            match = matches[0];
            matches = match.presentMatches;
          }
          label = match.label, ruleName = match.ruleName, nonMatch = match.nonMatch;
          path.push(ruleName);
          path = path.join('.');
          hasOneOrMoreMatchingChildren = false;
          children = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = matches.length; j < len; j++) {
              match = matches[j];
              if (!match.nonMatch) {
                hasOneOrMoreMatchingChildren = true;
              }
              results.push(match.getInspectedObjects(verbose));
            }
            return results;
          })();
          parts = compactFlatten([
            label ? {
              label: label
            } : void 0, {
              offset: this.offset,
              absoluteOffset: this.absoluteOffset
            }, children.length > 0 ? children : match.toString()
          ]);
          if (parts.length === 1) {
            parts = parts[0];
          }
          return (
            obj = {},
            obj["" + (nonMatch ? hasOneOrMoreMatchingChildren ? 'partialMatch-' : 'nonMatch-' : '') + path] = parts,
            obj
          );
        } else if (this.nonMatch) {
          return {
            nonMatch: merge({
              offset: this.offset,
              ruleName: this.ruleName,
              pattern: "" + ((ref2 = (ref3 = this.pattern) != null ? ref3.pattern : void 0) != null ? ref2 : (ref4 = this.ruleVariant) != null ? ref4.pattern : void 0)
            })
          };
        } else {
          if (verbose) {
            return {
              token: {
                offset: this.offset,
                length: this.matchLength,
                text: this.text,
                pattern: "" + ((ref5 = this.pattern) != null ? ref5.pattern : void 0),
                "class": this["class"].getName(),
                ruleName: this.ruleName
              }
            };
          } else {
            return this.text;
          }
        }
      },
      detailedInspectedObjects: function() {
        var children, match, matches, ret;
        matches = this.matches;
        if (matches.length > 0) {
          children = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = matches.length; j < len; j++) {
              match = matches[j];
              results.push(match.detailedInspectedObjects);
            }
            return results;
          })();
          ret = {};
          ret[this.name] = children.length === 1 ? children[0] : children;
          return ret;
        } else {
          return this.text;
        }
      },
      plainObjects: function() {
        var match, ref1, ret;
        ret = [
          {
            inspect: (function(_this) {
              return function() {
                return _this["class"].getName();
              };
            })(this)
          }
        ];
        if (((ref1 = this._matches) != null ? ref1.length : void 0) > 0) {
          ret = ret.concat((function() {
            var j, len, ref2, results;
            ref2 = this.matches;
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              match = ref2[j];
              results.push(match.getPlainObjects());
            }
            return results;
          }).call(this));
        } else {
          ret = this.text;
        }
        return ret;
      }
    });

    Node.prototype.find = function(searchName, out) {
      var j, len, m, ref1;
      if (out == null) {
        out = [];
      }
      ref1 = this.matches;
      for (j = 0, len = ref1.length; j < len; j++) {
        m = ref1[j];
        if (m.getName() === searchName) {
          out.push(m);
        } else {
          m.find(searchName, out);
        }
      }
      return out;
    };

    Node.prototype.subparse = function(subSource, options) {
      return this._parser.subparse(subSource, merge(options, {
        parentNode: this
      }));
    };


    /*
    IN: pattern, match - instanceof Node
    OUT: true if match was added
     */

    Node.prototype.addMatch = function(pattern, match) {
      if (!match) {
        return false;
      }
      this._matches = push(this._matches, match);
      this._matchPatterns = push(this._matchPatterns, pattern);
      this._matchLength = match.nextOffset - this.offset;
      return true;
    };

    Node.prototype.applyLabels = function() {
      if (!this._matches || this._labelsApplied) {
        return;
      }
      this._labelsApplied = true;
      return array(this._matches, (function(_this) {
        return function(match, i) {
          var label, pattern, pluralLabel, pluralRuleName, ruleName;
          pattern = _this._matchPatterns[i];
          match._parent = _this;
          if (pattern) {
            label = pattern.label, ruleName = pattern.ruleName;
            match._pattern = pattern;
            match._label = label;
            match._ruleName = ruleName;
          }
          if (label) {
            match._pluralLabel = pluralLabel = _this.parser.pluralize(label);
          }
          if (ruleName) {
            match._pluralRuleName = pluralRuleName = _this.parser.pluralize(ruleName);
          }
          label || (label = ruleName);
          pluralLabel || (pluralLabel = pluralRuleName);
          if (label && !(match instanceof Nodes.EmptyNode)) {
            _this._bindToLabelLists(pluralLabel, match);
            _this._bindToSingleLabels(label, match);
          }
          return match.applyLabels();
        };
      })(this));
    };

    Node.prototype._bindToLabelLists = function(pluralLabel, match) {
      if (this.__proto__[pluralLabel] == null) {
        return this[pluralLabel] = push(this[pluralLabel], match);
      }
    };

    Node.prototype._bindToSingleLabels = function(label, match) {
      if (this.__proto__[label] == null) {
        return this[label] = match;
      }
    };

    Node.prototype._addNonMatch = function(node) {
      return (this._nonMatches || (this._nonMatches = [])).push(node);
    };

    Node.prototype._addToParentAsNonMatch = function() {
      if (this._matchLength === 0) {
        this._matchLength = 1;
      }
      if (this.parent) {
        if (this.parent.matches) {
          if (!(0 <= this.parent.matches.indexOf(this))) {
            this._nonMatch = true;
            this.parent.matches.push(this);
            this.parent._presentMatches = null;
            if (this.parent._matchLength === 0) {
              this.parent._matchLength = 1;
            }
          }
          return this.parent._addToParentAsNonMatch();
        } else {
          return this;
        }
      } else {
        return this;
      }
    };

    return Node;

  })(BaseClass);

}).call(this);
