// Generated by CoffeeScript 1.12.7
(function() {
  var BaseClass, Node, PatternElement, RuleVariant, ScratchNode, Stats, allPatternElementsRegExp, compactFlatten, inspect, isPlainObject, isString, log, merge, pad, push, ref, ref1, toInspectedObjects, upperCamelCase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  PatternElement = require('./PatternElement');

  Stats = require('./Stats');

  ref = require('./Nodes'), Node = ref.Node, ScratchNode = ref.ScratchNode;

  ref1 = require('art-standard-lib'), log = ref1.log, toInspectedObjects = ref1.toInspectedObjects, isPlainObject = ref1.isPlainObject, push = ref1.push, isString = ref1.isString, compactFlatten = ref1.compactFlatten, inspect = ref1.inspect, pad = ref1.pad, upperCamelCase = ref1.upperCamelCase, merge = ref1.merge;

  allPatternElementsRegExp = PatternElement.allPatternElementsRegExp;

  BaseClass = require("art-class-system").BaseClass;

  module.exports = RuleVariant = (function(superClass) {
    extend(RuleVariant, superClass);

    function RuleVariant(options1) {
      var ref2;
      this.options = options1;
      this._toString = null;
      if (!isPlainObject(this.options)) {
        this.options = {
          pattern: this.options
        };
      }
      ref2 = this.options, this.pattern = ref2.pattern, this.rule = ref2.rule, this.parserClass = ref2.parserClass;
      this._variantNodeClassName = this.options.variantNodeClassName;
      this._initVariantNodeClass(this.options);
      if (this.options.parse) {
        this.parse = this.options.parse;
      }
    }

    RuleVariant.property({
      passThroughRuleName: null
    });

    RuleVariant.setter("variantNodeClassName");

    RuleVariant.getter({
      ruleName: function() {
        return this.rule.name;
      },
      inspectedObjects: function() {
        return toInspectedObjects(this.pattern);
      },
      isPassThrough: function() {
        return this._passThroughRuleName;
      },
      name: function() {
        return this.variantNodeClassName + "Variant";
      },
      numVariants: function() {
        return this.rule.numVariants;
      },
      patternElements: function() {
        return this._patternElements || (this._patternElements = this._generatePatternElements());
      }
    });

    RuleVariant.prototype._generatePatternElements = function() {
      var part, parts, pes;
      pes = (function() {
        var i, len, results;
        if (isString(this.pattern)) {
          parts = this.pattern.match(allPatternElementsRegExp);
          if (!parts) {
            throw new Error("no pattern-parts found in: " + (inspect(this.pattern)));
          }
          results = [];
          for (i = 0, len = parts.length; i < len; i++) {
            part = parts[i];
            results.push(new PatternElement(part, {
              ruleVariant: this
            }));
          }
          return results;
        } else {
          return [
            new PatternElement(this.pattern, {
              ruleVariant: this
            })
          ];
        }
      }).call(this);
      pes = compactFlatten(pes);
      if (pes.length === 1 && pes[0].isBasicRulePattern) {
        this.passThroughRuleName = pes[0].ruleName;
      }
      return pes;
    };

    RuleVariant.prototype.inspect = function() {
      return this.toString();
    };

    RuleVariant.prototype.toString = function() {
      return this._toString || (this._toString = this.name + ": " + this.patternString);
    };

    RuleVariant.getter({
      patternString: function() {
        return this.pattern || (this.options.parse && 'function()');
      }
    });


    /*
    see: Caffeine.Eight.Rule#parse
     */

    RuleVariant.prototype.parse = function(parentNode) {
      var activeRuleVariantParserOffsets, i, len, name, nextOffset, parser, patternElement, previousActiveRuleVariantParserOffset, ref2, scratchNode;
      name = this.name;
      parser = parentNode.parser, nextOffset = parentNode.nextOffset;
      activeRuleVariantParserOffsets = parser.activeRuleVariantParserOffsets;
      if (nextOffset === (previousActiveRuleVariantParserOffset = activeRuleVariantParserOffsets[name])) {
        throw new Error("leftRecursion detected: RuleVariant: " + name + ", offset: " + nextOffset);
      }
      activeRuleVariantParserOffsets[name] = nextOffset;
      try {
        Stats.add("parseVariant");
        scratchNode = ScratchNode.checkout(parentNode, this);
        parser = parentNode.parser;
        ref2 = this.patternElements;
        for (i = 0, len = ref2.length; i < len; i++) {
          patternElement = ref2[i];
          if (!parser.tryPatternElement(patternElement, scratchNode, this)) {
            scratchNode.checkin();
            return false;
          }
        }
        scratchNode.checkin();
        return scratchNode.getRealNode();
      } finally {
        activeRuleVariantParserOffsets[name] = previousActiveRuleVariantParserOffset;
      }
    };

    RuleVariant.getter({
      variantNodeClassName: function() {
        var baseName, ref2;
        if (this._variantNodeClassName) {
          return this._variantNodeClassName;
        }
        baseName = upperCamelCase(this.rule.name) + "Rule" + (this.pattern ? upperCamelCase(((ref2 = ("" + this.pattern).match(/[a-zA-Z0-9_]+/g)) != null ? ref2.join('_') : void 0) || "") : this.parse ? "CustomParser" : void 0);
        return this._variantNodeClassName = baseName;
      }
    });


    /*
    OPTIONS:
    
      node / nodeClass
        TODO: pick one, I like 'node' today
    
      extends / baseClass / nodeBaseClass
        TODO: pick one, I like 'extends' today
     */

    RuleVariant.prototype._initVariantNodeClass = function(options) {
      var nodeBaseClass, nodeSubclassOptions, rule;
      rule = options.rule;
      nodeSubclassOptions = options.node || options.nodeClass || options;
      nodeBaseClass = options["extends"] || options.baseClass || options.nodeBaseClass || Node;
      return this.VariantNodeClass = (typeof nodeClass !== "undefined" && nodeClass !== null ? nodeClass.prototype : void 0) instanceof Node ? nodeClass : nodeBaseClass.createSubclass(merge({
        name: this.variantNodeClassName,
        ruleVarient: this.ruleVarient
      }, nodeSubclassOptions));
    };

    return RuleVariant;

  })(BaseClass);

}).call(this);
