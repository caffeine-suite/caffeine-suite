// Generated by CoffeeScript 1.12.7
(function() {
  var CaffeineEightCompileError, Extensions, Parser, compactFlatten, defineModule, l, log, ref, ref1, validateCompileError, validateCompileError2, w,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Neptune.Caffeine.Eight, Parser = ref.Parser, CaffeineEightCompileError = ref.CaffeineEightCompileError, Extensions = ref.Extensions;

  ref1 = Neptune.Art.StandardLib, log = ref1.log, defineModule = ref1.defineModule, l = ref1.l, w = ref1.w, compactFlatten = ref1.compactFlatten;

  validateCompileError = function(error, testProps) {
    assert["instanceof"](CaffeineEightCompileError, error);
    assert.selectedPropsEq(testProps, error);
    return assert.match(error.message, /<HERE>/);
  };

  validateCompileError2 = function(parser, text, testedProps) {
    var myParser;
    myParser = new parser;
    return assert.rejects(function() {
      return myParser.parse(text);
    }).then(function(error) {
      assert["instanceof"](CaffeineEightCompileError, error);
      assert.selectedPropsEq(testedProps, error);
      return assert.match(error.message, /<HERE>/);
    });
  };

  defineModule(module, {
    suite: {
      info: function() {
        var MyParser;
        MyParser = null;
        setup(function() {
          return MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "myRule+",
              myRule: /foo\n?/
            });

            return MyParser;

          })(Parser);
        });
        test("baseline ok", function() {
          var myParser;
          myParser = new MyParser;
          return myParser.parse("foo");
        });
        test("0", function() {
          var myParser;
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("bad");
          }).then(function(error) {
            return validateCompileError(error, {
              failureIndex: 0,
              line: 0,
              column: 0
            });
          });
        });
        test("line 1, col 3", function() {
          var myParser;
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("foobad");
          }).then(function(error) {
            return validateCompileError(error, {
              failureIndex: 3,
              line: 0,
              column: 3,
              location: ":1:4"
            });
          });
        });
        test("line 2, col 1", function() {
          var myParser;
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("foo\nbad");
          }).then(function(error) {
            return validateCompileError(error, {
              failureIndex: 4,
              line: 1,
              column: 0
            });
          });
        });
        return test("line 2, col 4", function() {
          var myParser;
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("foo\nfoobar");
          }).then(function(error) {
            return validateCompileError(error, {
              failureIndex: 7,
              line: 1,
              column: 3
            });
          });
        });
      },
      infoOnNonFirstPattern: function() {
        var MyParser;
        MyParser = null;
        setup(function() {
          return MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: 'number _ /[a-z]+/',
              number: /[0-9]+/,
              _: /\s+/
            });

            return MyParser;

          })(Parser);
        });
        test("baseline", function() {
          return MyParser.parse("1 hi");
        });
        test("fail on first pattern", function() {
          return validateCompileError2(MyParser, "- hi", {
            failureIndex: 0,
            line: 0,
            column: 0,
            expectingInfo: {
              expecting: {
                "/[0-9]+/": {
                  "to-continue": "root",
                  "started-at": "1:1"
                }
              }
            }
          });
        });
        return test("fail on second pattern", function() {
          return validateCompileError2(MyParser, "1 HI", {
            failureIndex: 2,
            line: 0,
            column: 2,
            expectingInfo: {
              expecting: {
                "/[a-z]+/": {
                  "to-continue": "root",
                  "started-at": "1:1"
                }
              }
            }
          });
        });
      },
      basic: function() {
        return test("no match at all simple", function() {
          var MyParser, myParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "foo",
              foo: "bar",
              bar: /bar/
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("bad");
          }).then(function(error) {
            validateCompileError(error, {
              failureIndex: 0,
              line: 0,
              column: 0
            });
            return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/"]);
          });
        });
      },
      couldMatchKeys: function() {
        test("no match at all", function() {
          var MyParser, myParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "foo",
              foo: "bar? baz",
              bar: /bar/,
              baz: /baz/
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("bad");
          }).then(function(error) {
            validateCompileError(error, {
              failureIndex: 0,
              line: 0,
              column: 0
            });
            return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/", "BazRuleBazVariant: /baz/"]);
          });
        });
        return test("partial match", function() {
          var MyParser, myParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "foo",
              foo: "duh? bar? baz",
              duh: /duh/,
              bar: /bar/,
              baz: /baz/
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("duhbad");
          }).then(function(error) {
            validateCompileError(error, {
              failureIndex: 3,
              line: 0,
              column: 3
            });
            return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/", 'BazRuleBazVariant: /baz/']);
          });
        });
      },
      misc: function() {
        test("nonMatches keys", function() {
          var MyParser, myParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: w("foo bar baz"),
              foo: "'foo'",
              bar: /bar/,
              baz: '"baz"'
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("bad");
          }).then(function(error) {
            validateCompileError(error, {
              failureIndex: 0,
              line: 0,
              column: 0
            });
            return assert.eq(Object.keys(myParser.nonMatches).sort(), ["BarRuleBarVariant: /bar/", 'BazRuleBazVariant: "baz"', "FooRuleFooVariant: 'foo'"]);
          });
        });
        test("expectingInfo", function() {
          var MyParser, myParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "foobarbaz foobarbaz",
              foobarbaz: w("foo bar baz"),
              foo: "'foo'",
              bar: /bar/,
              baz: '"baz"'
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("barfo");
          }).then(function(error) {
            return validateCompileError(error, {
              failureIndex: 3,
              line: 0,
              column: 3
            });
          });
        });
        return test("matchingNegative", function() {
          var MyParser, myParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "foobarbaz foobarbaz",
              foobarbaz: w("foo bar baz"),
              foo: "'foo'",
              bar: /bar/,
              baz: '!boo "baz"',
              boo: /boo/
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          return assert.rejects(function() {
            return myParser.parse("baz");
          }).then(function(error) {
            return validateCompileError(error, {
              failureIndex: 3,
              line: 0,
              column: 3
            });
          });
        });
      }
    }
  });

}).call(this);
