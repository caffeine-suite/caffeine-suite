// Generated by CoffeeScript 1.12.7
(function() {
  var Node, Nodes, Parser, log, ref, ref1, wordsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Neptune.Art.StandardLib, log = ref.log, wordsArray = ref.wordsArray;

  ref1 = Neptune.Caffeine.Eight, Parser = ref1.Parser, Nodes = ref1.Nodes;

  Node = Nodes.Node;

  module.exports = {
    suite: {
      basic: function() {
        test("\"'foo'\"", function() {
          var MyParser, myParser, result;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "'foo'"
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          result = myParser.parse("foo");
          assert.eq(result.offset, 0);
          assert.eq(result.matchLength, 3);
          return assert.eq(result.text, "foo");
        });
        test("/foo/", function() {
          var MyParser, myParser, result;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: /foo/
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          result = myParser.parse("foo");
          assert.eq(result.offset, 0);
          assert.eq(result.matchLength, 3);
          return assert.eq(result.text, "foo");
        });
        test("/[0-9]+/", function() {
          var MyParser, i, len, ref2, result, results, source, sources;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: /[0-9]+/
            });

            return MyParser;

          })(Parser);
          ref2 = sources = wordsArray("0 1 10 123 1001");
          results = [];
          for (i = 0, len = ref2.length; i < len; i++) {
            source = ref2[i];
            result = MyParser.parse(source);
            assert.eq(result.offset, 0);
            assert.eq(result.matchLength, source.length);
            results.push(assert.eq(result.text, source));
          }
          return results;
        });
        return test("match /[0-9]+/ -- doesn't match if not at the start of the string", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              foo: /[0-9]+/
            });

            return MyParser;

          })(Parser);
          return assert.throws(function() {
            return MyParser.parse(" 0123");
          });
        });
      },
      "sequence parsing": function() {
        test("'foo' /bar/", function() {
          var MyParser, myParser, result;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "'foo' /bar/"
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          result = myParser.parse("foobar");
          assert.eq(result.offset, 0);
          assert.eq(result.matchLength, 6);
          return assert.eq(result.text, "foobar");
        });
        test("/foo/ /bar/", function() {
          var MyParser, myParser, result;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "/foo/ /bar/"
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          result = myParser.parse("foobar");
          assert.eq(result.offset, 0);
          assert.eq(result.matchLength, 6);
          return assert.eq(result.text, "foobar");
        });
        return test("/foo/ bar", function() {
          var MyParser, myParser, result;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: '/foo/ bar',
              bar: /bar/
            });

            return MyParser;

          })(Parser);
          myParser = new MyParser;
          result = myParser.parse("foobar");
          assert.eq(result.offset, 0);
          assert.eq(result.matchLength, 6);
          return assert.eq(result.text, "foobar");
        });
      },
      "conditional parsing": function() {
        test("conditional rule 'foo? bar'", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "foo? bar",
              bar: /bar/,
              foo: /foo/
            });

            return MyParser;

          })(Parser);
          MyParser.parse("bar");
          return MyParser.parse("foobar");
        });
        return test("conditional regExp '/foo/? bar'", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "/foo/? bar",
              bar: /bar/
            });

            return MyParser;

          })(Parser);
          MyParser.parse("bar");
          return MyParser.parse("foobar");
        });
      },
      "negative parsing": function() {
        return test("!boo anything", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "!boo anything",
              boo: /boo/,
              anything: /.*/
            });

            return MyParser;

          })(Parser);
          assert.throws(function() {
            return MyParser.parse("boo");
          });
          assert.throws(function() {
            return MyParser.parse("boobat");
          });
          return MyParser.parse("bobat");
        });
      },
      "couldMatch parsing": function() {
        return test("couldMatch: 'boo &foo rest'", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "boo &foo rest",
              boo: /boo/,
              foo: /foo/,
              rest: /fo[a-z]+/
            });

            return MyParser;

          })(Parser);
          MyParser.parse("boofoo");
          return assert.throws(function() {
            return MyParser.parse("boofoa");
          });
        });
      },
      "rule variants": function() {
        return test("two variants", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: /boo/
            });

            MyParser.rule({
              root: /foo/
            });

            return MyParser;

          })(Parser);
          MyParser.parse("boo");
          return MyParser.parse("foo");
        });
      },
      "many parsing": function() {
        test("boo*", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: 'boo*',
              boo: /boo/
            });

            return MyParser;

          })(Parser);
          MyParser.parse("");
          MyParser.parse("boo");
          return MyParser.parse("booboo");
        });
        return test("boo+", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: 'boo+',
              boo: /boo/
            });

            return MyParser;

          })(Parser);
          assert.throws(function() {
            return MyParser.parse("");
          });
          MyParser.parse("boo");
          return MyParser.parse("booboo");
        });
      },
      "custom parser": function() {
        test("basic", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: {
                parse: function(parentNode) {
                  var nextOffset, source;
                  nextOffset = parentNode.nextOffset, source = parentNode.source;
                  if (source[nextOffset] === "a") {
                    return new Node(parentNode, {
                      offset: nextOffset,
                      matchLength: 1,
                      ruleVariant: this
                    });
                  }
                }
              }
            });

            return MyParser;

          })(Parser);
          MyParser.parse("a");
          return assert.throws(function() {
            return MyParser.parse("A");
          });
        });
        return test("alternate custom parsers", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: [
                {
                  parse: function(parentNode) {
                    var nextOffset, source;
                    nextOffset = parentNode.nextOffset, source = parentNode.source;
                    if (source[nextOffset] === "a") {
                      return new Node(parentNode, {
                        offset: nextOffset,
                        matchLength: 1,
                        ruleVariant: this
                      });
                    }
                  }
                }, {
                  parse: function(parentNode) {
                    var nextOffset, source;
                    nextOffset = parentNode.nextOffset, source = parentNode.source;
                    if (source[nextOffset] === "b") {
                      return new Node(parentNode, {
                        offset: nextOffset,
                        matchLength: 1,
                        ruleVariant: this
                      });
                    }
                  }
                }
              ]
            });

            return MyParser;

          })(Parser);
          MyParser.parse("a");
          MyParser.parse("b");
          return assert.throws(function() {
            return MyParser.parse("A");
          });
        });
      },
      "prevent simple infinite loops": function() {
        test("/foo/ /$/*", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "/foo/ /$/*"
            });

            return MyParser;

          })(Parser);
          return MyParser.parse("foo");
        });
        return test("/foo/ /$/+", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: "/foo/ /$/+"
            });

            return MyParser;

          })(Parser);
          return MyParser.parse("foo");
        });
      },
      multiNotations: function() {
        test("rule root: []", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: [/foo/, /boo/]
            });

            return MyParser;

          })(Parser);
          MyParser.parse("foo");
          return MyParser.parse("boo");
        });
        test("rule root: [..., {}]", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: [
                /foo/, /boo/, {
                  custom: function() {
                    return this.text.toUpperCase();
                  }
                }
              ]
            });

            return MyParser;

          })(Parser);
          assert.eq("FOO", MyParser.parse("foo").custom());
          return assert.eq("BOO", MyParser.parse("boo").custom());
        });
        return test("rule root: pattern: [], ...", function() {
          var MyParser;
          MyParser = (function(superClass) {
            extend(MyParser, superClass);

            function MyParser() {
              return MyParser.__super__.constructor.apply(this, arguments);
            }

            MyParser.rule({
              root: {
                pattern: [/foo/, /boo/],
                custom: function() {
                  return this.text.toUpperCase();
                }
              }
            });

            return MyParser;

          })(Parser);
          assert.eq("FOO", MyParser.parse("foo").custom());
          return assert.eq("BOO", MyParser.parse("boo").custom());
        });
      }
    }
  };

}).call(this);
