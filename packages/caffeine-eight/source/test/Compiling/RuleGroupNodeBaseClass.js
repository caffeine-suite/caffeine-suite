// Generated by CoffeeScript 1.12.7
(function() {
  var Node, Nodes, Parser, a, log, lowerCamelCase, m, ref, ref1, upperCamelCase, w,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Neptune.Art.StandardLib, log = ref.log, a = ref.a, w = ref.w, m = ref.m, upperCamelCase = ref.upperCamelCase, lowerCamelCase = ref.lowerCamelCase;

  ref1 = Neptune.Caffeine.Eight, Parser = ref1.Parser, Nodes = ref1.Nodes;

  Node = Nodes.Node;

  module.exports = {
    suite: function() {
      var MyParser;
      MyParser = null;
      setup(function() {
        return MyParser = (function(superClass) {
          var MyNode;

          extend(MyParser, superClass);

          function MyParser() {
            return MyParser.__super__.constructor.apply(this, arguments);
          }

          MyParser.nodeBaseClass = MyNode = (function(superClass1) {
            extend(MyNode, superClass1);

            function MyNode() {
              return MyNode.__super__.constructor.apply(this, arguments);
            }

            MyNode.prototype.compile = function() {
              return ((function() {
                var i, len, ref2, results;
                ref2 = this.matches;
                results = [];
                for (i = 0, len = ref2.length; i < len; i++) {
                  a = ref2[i];
                  if (a.compile) {
                    results.push(a.compile());
                  }
                }
                return results;
              }).call(this)).join('');
            };

            return MyNode;

          })(Node);

          MyParser.rule({
            root: "noun _ verb _ noun",
            _: {
              pattern: / +/,
              compile: function() {
                return " ";
              }
            },
            noun: w("bugs butterflies")
          });

          MyParser.rule({
            bugs: /bugs|ladybugs|beetles/i,
            butterflies: /butterflies|skippers|swallowtails/i
          }, {
            compile: function() {
              return upperCamelCase(this.toString());
            }
          });

          MyParser.rule({
            verb: {
              pattern: /eat|shun/i,
              compile: function() {
                return lowerCamelCase(this.toString());
              }
            }
          });

          return MyParser;

        })(Parser);
      });
      test("one rule multiple patters shares a nodeBaseClass", function() {
        var mainNode;
        mainNode = MyParser.parse("ladybugs eat beetles");
        return assert.eq(mainNode.compile(), "Ladybugs eat Beetles");
      });
      return test("case insensitive", function() {
        var mainNode;
        mainNode = MyParser.parse("ladybugs EAT beetles");
        return assert.eq(mainNode.compile(), "Ladybugs eat Beetles");
      });
    }
  };

}).call(this);
