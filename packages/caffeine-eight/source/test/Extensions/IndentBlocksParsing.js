// Generated by CoffeeScript 1.12.7
(function() {
  var Extensions, Node, Parser, a, array, assert, compactFlatten, describe, log, peek, ref, ref1, ref2, ref3, shallowClone, w,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require("art-standard-lib"), w = ref.w, array = ref.array, log = ref.log, a = ref.a, peek = ref.peek, shallowClone = ref.shallowClone, compactFlatten = ref.compactFlatten;

  ref1 = require("../../"), Parser = ref1.Parser, (ref2 = ref1.Nodes, Node = ref2.Node), Extensions = ref1.Extensions;

  ref3 = require("art-testbench"), describe = ref3.describe, assert = ref3.assert;

  describe({
    toEolSubparsing: function() {
      var MyParser;
      MyParser = null;
      setup(function() {
        return MyParser = (function(superClass) {
          extend(MyParser, superClass);

          function MyParser() {
            return MyParser.__super__.constructor.apply(this, arguments);
          }

          MyParser.rule({
            root: 'line+',
            line: "linePart end",
            linePart: ["lineLabel lineEnd", "'(' linePart ')'"],
            end: '/\n|$/',
            lineEnd: Extensions.IndentBlocks.getPropsToSubparseToEol({
              rule: "word",
              allowPartialMatch: true
            }),
            lineLabel: /[0-9]+\: */,
            word: /[a-z]+/
          });

          return MyParser;

        })(Parser);
      });
      test("simple expression", function() {
        return MyParser.parse("1: hi");
      });
      test("partial toEol match works", function() {
        return MyParser.parse("(1: hi)");
      });
      return test("extra nesting", function() {
        return MyParser.parse("((1: hi))");
      });
    },
    ifThenElseWithPartialSubBlocks: function() {
      var IfThenElseParser;
      IfThenElseParser = null;
      setup(function() {
        return IfThenElseParser = (function(superClass) {
          extend(IfThenElseParser, superClass);

          function IfThenElseParser() {
            return IfThenElseParser.__super__.constructor.apply(this, arguments);
          }

          IfThenElseParser.rule({
            root: [
              {
                pattern: 'ifThenElse',
                toTestStructure: function() {
                  return this.ifThenElse.toTestStructure();
                }
              }, {
                pattern: 'words',
                toTestStructure: function() {
                  return this.words.toTestStructure();
                }
              }
            ],
            ifThenElse: {
              pattern: '/if/ _ testBody:expression _ /then/ _ thenBody:expression _ /else/ _ elseBody:expression',
              toTestStructure: function() {
                return {
                  test: this.testBody.toTestStructure(),
                  then: this.thenBody.toTestStructure(),
                  "else": this.elseBody.toTestStructure()
                };
              }
            },
            expression: {
              pattern: Extensions.IndentBlocks.getPropsToSubparseToEol({
                rule: "words",
                allowPartialMatch: true
              }),
              toTestStructure: function() {
                return this.matches[0].toTestStructure();
              }
            },
            words: {
              pattern: "word*",
              toTestStructure: function() {
                var i, len, ref4, results, word;
                ref4 = this.words;
                results = [];
                for (i = 0, len = ref4.length; i < len; i++) {
                  word = ref4[i];
                  results.push(word.toString().trim());
                }
                return results;
              }
            },
            word: "_? !/(if|then|else)\\b/ /[a-z]+/",
            _: /\ +/
          });

          return IfThenElseParser;

        })(Parser);
      });
      test("simple words", function() {
        return IfThenElseParser.parse("hi there");
      });
      test("simple if-then-else", function() {
        return IfThenElseParser.parse("if a then b else c");
      });
      return test("more if-then-else", function() {
        var result;
        result = IfThenElseParser.parse("if a b then c d else e f");
        return assert.eq(result.toTestStructure(), {
          test: ["a", "b"],
          then: ["c", "d"],
          "else": ["e", "f"]
        });
      });
    },
    absoluteOffset: function() {
      var MyBlockParser, validateAbsoluteOffsets;
      MyBlockParser = null;
      setup(function() {
        return MyBlockParser = (function(superClass) {
          extend(MyBlockParser, superClass);

          function MyBlockParser() {
            return MyBlockParser.__super__.constructor.apply(this, arguments);
          }

          MyBlockParser.rule({
            root: 'line+',
            line: ['end', 'expression block? end'],
            expression: '/[a-z0-9A-Z]+/',
            end: '/\n|$/',
            block: Extensions.IndentBlocks.getPropsToSubparseBlock()
          });

          return MyBlockParser;

        })(Parser);
      });
      validateAbsoluteOffsets = function(node) {
        var absoluteOffset, child, i, len, ref4, sourceValue;
        absoluteOffset = node.absoluteOffset;
        if (node.ruleName === "expression") {
          sourceValue = node.toString();
          assert.eq(absoluteOffset, node.parser.rootSource.indexOf(sourceValue), {
            sourceValue: sourceValue
          });
        }
        ref4 = node.children;
        for (i = 0, len = ref4.length; i < len; i++) {
          child = ref4[i];
          assert.lte(absoluteOffset, validateAbsoluteOffsets(child), {
            message: "parent node's absoluteOffset should be <= all of its children",
            node: node.toString(),
            child: child.toString()
          });
        }
        return absoluteOffset;
      };
      test("simple", function() {
        return validateAbsoluteOffsets(MyBlockParser.parse("alpha"));
      });
      test("one block", function() {
        return validateAbsoluteOffsets(MyBlockParser.parse("alpha\n  beautlful\n  colorful"));
      });
      return test("nested blocks", function() {
        var p;
        return validateAbsoluteOffsets(p = MyBlockParser.parse("alpha\n  beautlful\n  colorful\n    and\n    delightful"));
      });
    },
    blockParsing: function() {
      var MyBlockParser;
      MyBlockParser = null;
      setup(function() {
        return MyBlockParser = (function(superClass) {
          extend(MyBlockParser, superClass);

          function MyBlockParser() {
            return MyBlockParser.__super__.constructor.apply(this, arguments);
          }

          MyBlockParser.rule({
            root: 'line+',
            line: ['/!!!/', 'end', 'expression block? end'],
            expression: '/[a-z0-9A-Z]+/',
            end: '/\n|$/',
            block: Extensions.IndentBlocks.getPropsToSubparseBlock()
          });

          return MyBlockParser;

        })(Parser);
      });
      test("simple expression", function() {
        return MyBlockParser.parse("one");
      });
      test("one block", function() {
        return MyBlockParser.parse("one\n  two");
      });
      test("nested blocks", function() {
        return MyBlockParser.parse("one\n  two\n    three");
      });
      return suite("failure location", function() {
        suite('baseline without block', function() {
          test("before first line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("-abc");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 0);
            });
          });
          test("first line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc-");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 3);
            });
          });
          return test("second line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc\nfoo-");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 7);
            });
          });
        });
        suite('in block', function() {
          test("before line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc\n  -def\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 6);
            });
          });
          test("first line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc\n  def-\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 9);
            });
          });
          return test("second line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc\n  def\n  foos-");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 16);
            });
          });
        });
        return suite("in nested block", function() {
          test("first line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc\n  def\n    dood-\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 18);
            });
          });
          return test("second line", function() {
            var parser;
            parser = new MyBlockParser;
            return assert.rejects(function() {
              return parser.parse("abc\n  def2\n    dood\n    goof-\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 28);
            });
          });
        });
      });
    },
    eolOrBlockParsing: function() {
      var MyEolOrBlockParser;
      MyEolOrBlockParser = null;
      setup(function() {
        return MyEolOrBlockParser = (function(superClass) {
          extend(MyEolOrBlockParser, superClass);

          function MyEolOrBlockParser() {
            return MyEolOrBlockParser.__super__.constructor.apply(this, arguments);
          }

          MyEolOrBlockParser.rule({
            root: 'expression block? end',
            expression: '/[a-z0-9A-Z]+/',
            end: '/\n|$/',
            block: Extensions.IndentBlocks.getPropsToSubparseToEolAndBlock()
          });

          return MyEolOrBlockParser;

        })(Parser);
      });
      test("simple expression", function() {
        return MyEolOrBlockParser.parse("one");
      });
      test("simple block", function() {
        return MyEolOrBlockParser.parse("one\n  two");
      });
      test("simple eol", function() {
        return MyEolOrBlockParser.parse("one two");
      });
      test("nested blocks", function() {
        return MyEolOrBlockParser.parse("one\n  two\n    three");
      });
      test("nested eols", function() {
        return MyEolOrBlockParser.parse("one two three");
      });
      test("nested eols and blocks", function() {
        return MyEolOrBlockParser.parse("one two\n  three");
      });
      return suite("failure location", function() {
        test("in EOL content", function() {
          var parser;
          parser = new MyEolOrBlockParser;
          return assert.rejects(function() {
            return parser.parse("one -two");
          }).then(function(rejectsWith) {
            return assert.eq(parser._failureIndex, 4);
          });
        });
        test("in block with EOL content", function() {
          var parser;
          parser = new MyEolOrBlockParser;
          return assert.rejects(function() {
            return parser.parse("one two\n  -abc");
          }).then(function(rejectsWith) {
            return assert.eq(parser._failureIndex, 10);
          });
        });
        return test("in block without EOL content", function() {
          var parser;
          parser = new MyEolOrBlockParser;
          return assert.rejects(function() {
            return parser.parse("one\n  -abc");
          }).then(function(rejectsWith) {
            return assert.eq(parser._failureIndex, 6);
          });
        });
      });
    },
    CaffeineScriptObjectNotation: function() {
      var IndentBlocksNode, MyParser;
      IndentBlocksNode = MyParser = null;
      setup(function() {
        IndentBlocksNode = (function(superClass) {
          extend(IndentBlocksNode, superClass);

          function IndentBlocksNode() {
            return IndentBlocksNode.__super__.constructor.apply(this, arguments);
          }

          IndentBlocksNode.prototype.toJs = function() {
            var i, len, match, ref4;
            ref4 = this.matches;
            for (i = 0, len = ref4.length; i < len; i++) {
              match = ref4[i];
              if (match.toJs) {
                return match.toJs();
              }
            }
            log({
              "no matches have toJs": {
                self: this,
                "class": this["class"],
                matches: this.matches,
                parseTreePath: this.parseTreePath
              }
            });
            throw new Error("no matches have toJs");
          };

          return IndentBlocksNode;

        })(Node);
        return MyParser = (function(superClass) {
          extend(MyParser, superClass);

          function MyParser() {
            return MyParser.__super__.constructor.apply(this, arguments);
          }

          MyParser.nodeBaseClass = IndentBlocksNode;

          MyParser.rules({
            root: 'statement+',
            block: Extensions.IndentBlocks.getPropsToSubparseBlock(),
            expression: w('object array block literal'),
            literal: {
              pattern: w('string number'),
              toJs: function() {
                return this.text;
              }
            },
            end: ['block end', '/\n+|$/'],
            statement: ['objectStatement end', 'expression end'],
            string: /"([^"]|\\.)*"/,
            number: /-?(\.[0-9]+|[0-9]+(\.[0-9]+)?)/,
            array: a({
              pattern: "'[]' block",
              toJs: function() {
                var node;
                return "[" + (((function() {
                  var i, len, ref4, results;
                  ref4 = this.block.statements;
                  results = [];
                  for (i = 0, len = ref4.length; i < len; i++) {
                    node = ref4[i];
                    results.push(node.toJs());
                  }
                  return results;
                }).call(this)).join(', ')) + "]";
              }
            }, {
              pattern: "'[]' _? arrayElementWithDelimiter* expression",
              toJs: function() {
                var node;
                return "[" + (((function() {
                  var i, len, ref4, results;
                  ref4 = compactFlatten([this.arrayElementWithDelimiters, this.expression]);
                  results = [];
                  for (i = 0, len = ref4.length; i < len; i++) {
                    node = ref4[i];
                    results.push(node.toJs());
                  }
                  return results;
                }).call(this)).join(', ')) + "]";
              }
            }, {
              pattern: "'[]'",
              toJs: function() {
                return this.text;
              }
            }),
            arrayElementWithDelimiter: "expression _? ',' _?",
            object: [
              "'{}' block", {
                pattern: "'{}'? _? objectPropList",
                toJs: function() {
                  return (this.objectPropList || this.block).toJs();
                }
              }
            ],
            objectStatement: {
              pattern: "objectProp objectPropLine*",
              toJs: function() {
                var m;
                return "{" + (((function() {
                  var i, len, ref4, results;
                  ref4 = compactFlatten([this.objectProp, this.objectPropLines]);
                  results = [];
                  for (i = 0, len = ref4.length; i < len; i++) {
                    m = ref4[i];
                    results.push(m.toJs());
                  }
                  return results;
                }).call(this)).join(', ')) + "}";
              }
            },
            objectPropLine: {
              pattern: "end objectProp",
              toJs: function() {
                return this.objectProp.toJs();
              }
            },
            objectPropList: {
              pattern: "objectProp objectPropListItem*",
              toJs: function() {
                var m;
                return "{" + (((function() {
                  var i, len, ref4, results;
                  ref4 = compactFlatten([this.objectProp, this.objectPropListItems]);
                  results = [];
                  for (i = 0, len = ref4.length; i < len; i++) {
                    m = ref4[i];
                    results.push(m.toJs());
                  }
                  return results;
                }).call(this)).join(', ')) + "}";
              }
            },
            objectPropListItem: {
              pattern: '"," _? objectProp',
              toJs: function() {
                return this.objectProp.toJs();
              }
            },
            objectProp: {
              pattern: 'objectPropLabel _? colon _? expression',
              toJs: function() {
                return this.objectPropLabel + ": " + (this.expression.toJs());
              }
            },
            commaOrEnd: ["',' _?", "end"],
            objectPropLabel: /[_a-zA-Z][_a-zA-Z0-9.]*/,
            colon: /\:/,
            _: / +/
          });

          return MyParser;

        })(Parser);
      });
      suite("parsing literals", function() {
        test("string expression", function() {
          return MyParser.parse('"hi"');
        });
        return test("number expression", function() {
          MyParser.parse('.1');
          MyParser.parse('0.1');
          MyParser.parse('0');
          return MyParser.parse('-100');
        });
      });
      suite("parsing objects", function() {
        test("one line", function() {
          MyParser.parse('hi:123');
          return MyParser.parse('hi:123, bye:345');
        });
        test("object expression", function() {
          MyParser.parse('hi:123');
          MyParser.parse("hi:    123\nthere: 456");
          return MyParser.parse("{}\n  hi:    123\n  there: 456");
        });
        return test("nested object expression", function() {
          return MyParser.parse("hi:    123\nthere:\n  one: 123\n  two: 456");
        });
      });
      suite("parsing arrays", function() {
        return test("array", function() {
          MyParser.parse('[]');
          MyParser.parse('[] 1');
          return MyParser.parse("[]\n  1");
        });
      });
      suite("toJs literals", function() {
        return test("string expression", function() {
          return assert.eq(MyParser.parse('"hi"').toJs(), '"hi"');
        });
      });
      suite("toJs objects", function() {
        test("simple", function() {
          return assert.eq(MyParser.parse('hi: 123').toJs(), "{hi: 123}");
        });
        test("object expression implicit one-liner", function() {
          return assert.eq(MyParser.parse('hi: 123, bye:456').toJs(), "{hi: 123, bye: 456}");
        });
        test("object expression explicit one-liner", function() {
          return assert.eq(MyParser.parse('{} hi: 123, bye:456').toJs(), "{hi: 123, bye: 456}");
        });
        test("object statement", function() {
          var p;
          p = MyParser.parse("foo: 123\nbar: \"hi\"\nbaz: .1");
          return assert.eq(p.toJs(), '{foo: 123, bar: "hi", baz: .1}');
        });
        test("object statement with nested object expression", function() {
          var p;
          p = MyParser.parse("foo: bar: 123\nbaz: 456");
          return assert.eq(p.toJs(), '{foo: {bar: 123}, baz: 456}');
        });
        test("nested object statements", function() {
          var parsed;
          parsed = MyParser.parse("foo: 123\nbar:\n  baz: 2\n  bud: 3");
          return assert.eq(parsed.toJs(), '{foo: 123, bar: {baz: 2, bud: 3}}');
        });
        return test("nested object expression one line", function() {
          return assert.eq(MyParser.parse("foo: 123\nbar: baz: 2, bud: 3").toJs(), '{foo: 123, bar: {baz: 2, bud: 3}}');
        });
      });
      suite("toJs array", function() {
        return test("array", function() {
          assert.eq(MyParser.parse('[]').toJs(), "[]");
          assert.eq(MyParser.parse('[] 1').toJs(), "[1]");
          assert.eq(MyParser.parse('[] 1, 2').toJs(), "[1, 2]");
          return assert.eq(MyParser.parse("[]\n  123\n  456").toJs(), "[123, 456]");
        });
      });
      return suite("toJs complex", function() {
        return test("everything", function() {
          return assert.eq(MyParser.parse("myNumber1: .10\nmyNumber2: 1\nmyNumber3: 1.1\n\nmyArray1: []\n  123\n  456\nmyArray2: [] \"hello\", \"world\"\n\nmyObject1: foo: 1, bar: 2\nmyObject2: {} foo: 1, bar: 2").toJs(), "{myNumber1: .10, myNumber2: 1, myNumber3: 1.1, myArray1: [123, 456], myArray2: [\"hello\", \"world\"], myObject1: {foo: 1, bar: 2}, myObject2: {foo: 1, bar: 2}}");
        });
      });
    }
  });

}).call(this);
