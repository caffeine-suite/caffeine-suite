// Generated by CoffeeScript 1.12.7
(function() {
  var Extensions, Node, Parser, a, array, assert, compactFlatten, createMyBlockParser, createMyEolOrBlockParser, createObjectNotationParser, describe, log, peek, ref, ref1, ref2, ref3, shallowClone, w,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require("art-standard-lib"), w = ref.w, array = ref.array, log = ref.log, a = ref.a, peek = ref.peek, shallowClone = ref.shallowClone, compactFlatten = ref.compactFlatten;

  ref1 = require("../../"), Parser = ref1.Parser, (ref2 = ref1.Nodes, Node = ref2.Node), Extensions = ref1.Extensions;

  ref3 = require("art-testbench"), describe = ref3.describe, assert = ref3.assert;

  createMyBlockParser = function() {
    var MyBlockParser;
    return MyBlockParser = (function(superClass) {
      extend(MyBlockParser, superClass);

      function MyBlockParser() {
        return MyBlockParser.__super__.constructor.apply(this, arguments);
      }

      MyBlockParser.rule({
        root: 'line+',
        line: ['/!!!/', 'end', 'expression block? end'],
        expression: '/[a-z0-9A-Z]+/',
        end: '/\n|$/',
        block: Extensions.IndentBlocks.getPropsToSubparseBlock()
      });

      return MyBlockParser;

    })(Parser);
  };

  createMyEolOrBlockParser = function() {
    var MyEolOrBlockParser;
    return MyEolOrBlockParser = (function(superClass) {
      extend(MyEolOrBlockParser, superClass);

      function MyEolOrBlockParser() {
        return MyEolOrBlockParser.__super__.constructor.apply(this, arguments);
      }

      MyEolOrBlockParser.rule({
        root: 'expression block? end',
        expression: '/[a-z0-9A-Z]+/',
        end: '/\n|$/',
        block: Extensions.IndentBlocks.getPropsToSubparseToEolAndBlock()
      });

      return MyEolOrBlockParser;

    })(Parser);
  };

  createObjectNotationParser = function() {
    var IndentBlocksNode, ObjectNotationParser;
    IndentBlocksNode = (function(superClass) {
      extend(IndentBlocksNode, superClass);

      function IndentBlocksNode() {
        return IndentBlocksNode.__super__.constructor.apply(this, arguments);
      }

      IndentBlocksNode.prototype.toJs = function() {
        var i, len, match, ref4;
        ref4 = this.matches;
        for (i = 0, len = ref4.length; i < len; i++) {
          match = ref4[i];
          if (match.toJs) {
            return match.toJs();
          }
        }
        log({
          "no matches have toJs": {
            self: this,
            "class": this["class"],
            matches: this.matches,
            parseTreePath: this.parseTreePath
          }
        });
        throw new Error("no matches have toJs");
      };

      return IndentBlocksNode;

    })(Node);
    return ObjectNotationParser = (function(superClass) {
      extend(ObjectNotationParser, superClass);

      function ObjectNotationParser() {
        return ObjectNotationParser.__super__.constructor.apply(this, arguments);
      }

      ObjectNotationParser.nodeBaseClass = IndentBlocksNode;

      ObjectNotationParser.rules({
        root: 'statement+',
        block: Extensions.IndentBlocks.getPropsToSubparseBlock(),
        expression: w('object array block literal'),
        literal: {
          pattern: w('string number'),
          toJs: function() {
            return this.text;
          }
        },
        end: ['block end', '/\n+|$/'],
        statement: ['objectStatement end', 'expression end'],
        string: /"([^"]|\\.)*"/,
        number: /-?(\.[0-9]+|[0-9]+(\.[0-9]+)?)/,
        array: a({
          pattern: "'[]' block",
          toJs: function() {
            var node;
            return "[" + (((function() {
              var i, len, ref4, results;
              ref4 = this.block.statements;
              results = [];
              for (i = 0, len = ref4.length; i < len; i++) {
                node = ref4[i];
                results.push(node.toJs());
              }
              return results;
            }).call(this)).join(', ')) + "]";
          }
        }, {
          pattern: "'[]' _? arrayElementWithDelimiter* expression",
          toJs: function() {
            var node;
            return "[" + (((function() {
              var i, len, ref4, results;
              ref4 = compactFlatten([this.arrayElementWithDelimiters, this.expression]);
              results = [];
              for (i = 0, len = ref4.length; i < len; i++) {
                node = ref4[i];
                results.push(node.toJs());
              }
              return results;
            }).call(this)).join(', ')) + "]";
          }
        }, {
          pattern: "'[]'",
          toJs: function() {
            return this.text;
          }
        }),
        arrayElementWithDelimiter: "expression _? ',' _?",
        object: [
          "'{}' block", {
            pattern: "'{}'? _? objectPropList",
            toJs: function() {
              return (this.objectPropList || this.block).toJs();
            }
          }
        ],
        objectStatement: {
          pattern: "objectProp objectPropLine*",
          toJs: function() {
            var m;
            return "{" + (((function() {
              var i, len, ref4, results;
              ref4 = compactFlatten([this.objectProp, this.objectPropLines]);
              results = [];
              for (i = 0, len = ref4.length; i < len; i++) {
                m = ref4[i];
                results.push(m.toJs());
              }
              return results;
            }).call(this)).join(', ')) + "}";
          }
        },
        objectPropLine: {
          pattern: "end objectProp",
          toJs: function() {
            return this.objectProp.toJs();
          }
        },
        objectPropList: {
          pattern: "objectProp objectPropListItem*",
          toJs: function() {
            var m;
            return "{" + (((function() {
              var i, len, ref4, results;
              ref4 = compactFlatten([this.objectProp, this.objectPropListItems]);
              results = [];
              for (i = 0, len = ref4.length; i < len; i++) {
                m = ref4[i];
                results.push(m.toJs());
              }
              return results;
            }).call(this)).join(', ')) + "}";
          }
        },
        objectPropListItem: {
          pattern: '"," _? objectProp',
          toJs: function() {
            return this.objectProp.toJs();
          }
        },
        objectProp: {
          pattern: 'objectPropLabel _? colon _? expression',
          toJs: function() {
            return this.objectPropLabel + ": " + (this.expression.toJs());
          }
        },
        commaOrEnd: ["',' _?", "end"],
        objectPropLabel: /[_a-zA-Z][_a-zA-Z0-9.]*/,
        colon: /\:/,
        _: / +/
      });

      return ObjectNotationParser;

    })(Parser);
  };

  describe({
    toEolSubparsing: function() {
      var MyParser;
      MyParser = null;
      beforeEach(function() {
        return MyParser = (function(superClass) {
          extend(MyParser, superClass);

          function MyParser() {
            return MyParser.__super__.constructor.apply(this, arguments);
          }

          MyParser.rule({
            root: 'line+',
            line: "linePart end",
            linePart: ["lineLabel lineEnd", "'(' linePart ')'"],
            end: '/\n|$/',
            lineEnd: Extensions.IndentBlocks.getPropsToSubparseToEol({
              rule: "word",
              allowPartialMatch: true
            }),
            lineLabel: /[0-9]+\: */,
            word: /[a-z]+/
          });

          return MyParser;

        })(Parser);
      });
      test("simple expression", function() {
        MyParser.parse("1: hi");
        return void 0;
      });
      test("partial toEol match works", function() {
        MyParser.parse("(1: hi)");
        return void 0;
      });
      return test("extra nesting", function() {
        MyParser.parse("((1: hi))");
        return void 0;
      });
    },
    ifThenElseWithPartialSubBlocks: function() {
      var IfThenElseParser;
      IfThenElseParser = null;
      beforeEach(function() {
        return IfThenElseParser = (function(superClass) {
          extend(IfThenElseParser, superClass);

          function IfThenElseParser() {
            return IfThenElseParser.__super__.constructor.apply(this, arguments);
          }

          IfThenElseParser.rule({
            root: [
              {
                pattern: 'ifThenElse',
                toTestStructure: function() {
                  return this.ifThenElse.toTestStructure();
                }
              }, {
                pattern: 'words',
                toTestStructure: function() {
                  return this.words.toTestStructure();
                }
              }
            ],
            ifThenElse: {
              pattern: '/if/ _ testBody:expression _ /then/ _ thenBody:expression _ /else/ _ elseBody:expression',
              toTestStructure: function() {
                return {
                  test: this.testBody.toTestStructure(),
                  then: this.thenBody.toTestStructure(),
                  "else": this.elseBody.toTestStructure()
                };
              }
            },
            expression: {
              pattern: Extensions.IndentBlocks.getPropsToSubparseToEol({
                rule: "words",
                allowPartialMatch: true
              }),
              toTestStructure: function() {
                return this.matches[0].toTestStructure();
              }
            },
            words: {
              pattern: "word*",
              toTestStructure: function() {
                var i, len, ref4, results, word;
                ref4 = this.words;
                results = [];
                for (i = 0, len = ref4.length; i < len; i++) {
                  word = ref4[i];
                  results.push(word.toString().trim());
                }
                return results;
              }
            },
            word: "_? !/(if|then|else)\\b/ /[a-z]+/",
            _: /\ +/
          });

          return IfThenElseParser;

        })(Parser);
      });
      test("simple words", function() {
        IfThenElseParser.parse("hi there");
        return void 0;
      });
      test("simple if-then-else", function() {
        IfThenElseParser.parse("if a then b else c");
        return void 0;
      });
      return test("more if-then-else", function() {
        var result;
        result = IfThenElseParser.parse("if a b then c d else e f");
        return assert.eq(result.toTestStructure(), {
          test: ["a", "b"],
          then: ["c", "d"],
          "else": ["e", "f"]
        });
      });
    },
    absoluteOffset: function() {
      var MyBlockParser, validateAbsoluteOffsets;
      MyBlockParser = null;
      beforeEach(function() {
        return MyBlockParser = (function(superClass) {
          extend(MyBlockParser, superClass);

          function MyBlockParser() {
            return MyBlockParser.__super__.constructor.apply(this, arguments);
          }

          MyBlockParser.rule({
            root: 'line+',
            line: ['end', 'expression block? end'],
            expression: '/[a-z0-9A-Z]+/',
            end: '/\n|$/',
            block: Extensions.IndentBlocks.getPropsToSubparseBlock()
          });

          return MyBlockParser;

        })(Parser);
      });
      validateAbsoluteOffsets = function(node) {
        var absoluteOffset, child, i, len, ref4, sourceValue;
        absoluteOffset = node.absoluteOffset;
        if (node.ruleName === "expression") {
          sourceValue = node.toString();
          assert.eq(absoluteOffset, node.parser.rootSource.indexOf(sourceValue), {
            sourceValue: sourceValue
          });
        }
        ref4 = node.children;
        for (i = 0, len = ref4.length; i < len; i++) {
          child = ref4[i];
          assert.lte(absoluteOffset, validateAbsoluteOffsets(child), {
            message: "parent node's absoluteOffset should be <= all of its children",
            node: node.toString(),
            child: child.toString()
          });
        }
        return absoluteOffset;
      };
      test("simple", function() {
        validateAbsoluteOffsets(MyBlockParser.parse("alpha"));
        return void 0;
      });
      test("one block", function() {
        validateAbsoluteOffsets(MyBlockParser.parse("alpha\n  beautlful\n  colorful"));
        return void 0;
      });
      return test("nested blocks", function() {
        var p;
        validateAbsoluteOffsets(p = MyBlockParser.parse("alpha\n  beautlful\n  colorful\n    and\n    delightful"));
        return void 0;
      });
    },
    blockParsing: {
      basic: function() {
        test("simple expression", function() {
          createMyBlockParser().parse("one");
          return void 0;
        });
        test("one block", function() {
          createMyBlockParser().parse("one\n  two");
          return void 0;
        });
        return test("nested blocks", function() {
          createMyBlockParser().parse("one\n  two\n    three");
          return void 0;
        });
      },
      failure_location: {
        baseline_without_block: function() {
          test("before first line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("-abc");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 0);
            });
          });
          test("first line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc-");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 3);
            });
          });
          return test("second line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc\nfoo-");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 7);
            });
          });
        },
        in_block: function() {
          test("before line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc\n  -def\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 6);
            });
          });
          test("first line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc\n  def-\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 9);
            });
          });
          return test("second line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc\n  def\n  foos-");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 16);
            });
          });
        },
        in_nested_block: function() {
          test("first line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc\n  def\n    dood-\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 18);
            });
          });
          return test("second line", function() {
            var parser;
            parser = new (createMyBlockParser());
            return assert.rejects(function() {
              return parser.parse("abc\n  def2\n    dood\n    goof-\n  foos");
            }).then(function(rejectsWith) {
              return assert.eq(parser._failureIndex, 28);
            });
          });
        }
      }
    },
    eolOrBlockParsing: {
      basics: function() {
        test("simple expression", function() {
          createMyEolOrBlockParser().parse("one");
          return void 0;
        });
        test("simple block", function() {
          createMyEolOrBlockParser().parse("one\n  two");
          return void 0;
        });
        test("simple eol", function() {
          createMyEolOrBlockParser().parse("one two");
          return void 0;
        });
        test("nested blocks", function() {
          createMyEolOrBlockParser().parse("one\n  two\n    three");
          return void 0;
        });
        test("nested eols", function() {
          createMyEolOrBlockParser().parse("one two three");
          return void 0;
        });
        return test("nested eols and blocks", function() {
          createMyEolOrBlockParser().parse("one two\n  three");
          return void 0;
        });
      },
      failure_location: function() {
        test("in EOL content", function() {
          var parser;
          parser = new (createMyEolOrBlockParser());
          return assert.rejects(function() {
            return parser.parse("one -two");
          }).then(function(rejectsWith) {
            return assert.eq(parser._failureIndex, 4);
          });
        });
        test("in block with EOL content", function() {
          var parser;
          parser = new (createMyEolOrBlockParser());
          return assert.rejects(function() {
            return parser.parse("one two\n  -abc");
          }).then(function(rejectsWith) {
            return assert.eq(parser._failureIndex, 10);
          });
        });
        return test("in block without EOL content", function() {
          var parser;
          parser = new (createMyEolOrBlockParser());
          return assert.rejects(function() {
            return parser.parse("one\n  -abc");
          }).then(function(rejectsWith) {
            return assert.eq(parser._failureIndex, 6);
          });
        });
      }
    },
    CaffeineScriptObjectNotation: {
      "parsing literals": function() {
        test("string expression", function() {
          createObjectNotationParser().parse('"hi"');
          return void 0;
        });
        return test("number expression", function() {
          createObjectNotationParser().parse('.1');
          createObjectNotationParser().parse('0.1');
          createObjectNotationParser().parse('0');
          createObjectNotationParser().parse('-100');
          return void 0;
        });
      },
      "parsing objects": function() {
        test("one line", function() {
          createObjectNotationParser().parse('hi:123');
          createObjectNotationParser().parse('hi:123, bye:345');
          return void 0;
        });
        test("object expression", function() {
          createObjectNotationParser().parse('hi:123');
          createObjectNotationParser().parse("hi:    123\nthere: 456");
          createObjectNotationParser().parse("{}\n  hi:    123\n  there: 456");
          return void 0;
        });
        return test("nested object expression", function() {
          createObjectNotationParser().parse("hi:    123\nthere:\n  one: 123\n  two: 456");
          return void 0;
        });
      },
      "parsing arrays": function() {
        return test("array", function() {
          createObjectNotationParser().parse('[]');
          createObjectNotationParser().parse('[] 1');
          createObjectNotationParser().parse("[]\n  1");
          return void 0;
        });
      },
      "toJs literals": function() {
        return test("string expression", function() {
          return assert.eq(createObjectNotationParser().parse('"hi"').toJs(), '"hi"');
        });
      },
      "toJs objects": function() {
        test("simple", function() {
          return assert.eq(createObjectNotationParser().parse('hi: 123').toJs(), "{hi: 123}");
        });
        test("object expression implicit one-liner", function() {
          return assert.eq(createObjectNotationParser().parse('hi: 123, bye:456').toJs(), "{hi: 123, bye: 456}");
        });
        test("object expression explicit one-liner", function() {
          return assert.eq(createObjectNotationParser().parse('{} hi: 123, bye:456').toJs(), "{hi: 123, bye: 456}");
        });
        test("object statement", function() {
          var p;
          p = createObjectNotationParser().parse("foo: 123\nbar: \"hi\"\nbaz: .1");
          return assert.eq(p.toJs(), '{foo: 123, bar: "hi", baz: .1}');
        });
        test("object statement with nested object expression", function() {
          var p;
          p = createObjectNotationParser().parse("foo: bar: 123\nbaz: 456");
          return assert.eq(p.toJs(), '{foo: {bar: 123}, baz: 456}');
        });
        test("nested object statements", function() {
          var parsed;
          parsed = createObjectNotationParser().parse("foo: 123\nbar:\n  baz: 2\n  bud: 3");
          return assert.eq(parsed.toJs(), '{foo: 123, bar: {baz: 2, bud: 3}}');
        });
        return test("nested object expression one line", function() {
          return assert.eq(createObjectNotationParser().parse("foo: 123\nbar: baz: 2, bud: 3").toJs(), '{foo: 123, bar: {baz: 2, bud: 3}}');
        });
      },
      "toJs array": function() {
        return test("array", function() {
          assert.eq(createObjectNotationParser().parse('[]').toJs(), "[]");
          assert.eq(createObjectNotationParser().parse('[] 1').toJs(), "[1]");
          assert.eq(createObjectNotationParser().parse('[] 1, 2').toJs(), "[1, 2]");
          return assert.eq(createObjectNotationParser().parse("[]\n  123\n  456").toJs(), "[123, 456]");
        });
      },
      "toJs complex": function() {
        return test("everything", function() {
          return assert.eq(createObjectNotationParser().parse("myNumber1: .10\nmyNumber2: 1\nmyNumber3: 1.1\n\nmyArray1: []\n  123\n  456\nmyArray2: [] \"hello\", \"world\"\n\nmyObject1: foo: 1, bar: 2\nmyObject2: {} foo: 1, bar: 2").toJs(), "{myNumber1: .10, myNumber2: 1, myNumber3: 1.1, myArray1: [123, 456], myArray2: [\"hello\", \"world\"], myObject1: {foo: 1, bar: 2}, myObject2: {foo: 1, bar: 2}}");
        });
      }
    }
  });

}).call(this);
